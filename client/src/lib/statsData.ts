export interface WizardStep {
  id: string;
  title: string;
  question: string;
  options: {
    value: string;
    label: string;
    description?: string;
  }[];
}

export interface StatTest {
  id: string;
  name: string;
  description: string;
  assumptions: string[];
  whenToUse: string[];
  alternatives: string[];
  methodFamily: string;
  category: string;
  categoryId: string;
  outcomeScale?: string | null;
  predictorStructure?: string | null;
  design?: string | null;
  level?: string | null;
  alternativeLinks?: string[];
  wikipediaUrl?: string | null;
  pythonCode?: string;
  rCode?: string;
}

export const wikipediaUrls: Record<string, string> = {
  "t-test-independent": "https://en.wikipedia.org/wiki/Student%27s_t-test",
  "paired-t-test": "https://en.wikipedia.org/wiki/Student%27s_t-test",
  "one-way-anova": "https://en.wikipedia.org/wiki/One-way_analysis_of_variance",
  "two-way-anova": "https://en.wikipedia.org/wiki/Two-way_analysis_of_variance",
  "repeated-measures-anova": "https://en.wikipedia.org/wiki/Repeated_measures_design",
  "mann-whitney": "https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test",
  "wilcoxon-signed-rank": "https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test",
  "kruskal-wallis": "https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_test",
  "friedman-test": "https://en.wikipedia.org/wiki/Friedman_test",
  "pearson-correlation": "https://en.wikipedia.org/wiki/Pearson_correlation_coefficient",
  "spearman-correlation": "https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient",
  "kendall-tau": "https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient",
  "point-biserial": "https://en.wikipedia.org/wiki/Point-biserial_correlation_coefficient",
  "partial-correlation": "https://en.wikipedia.org/wiki/Partial_correlation",
  "intraclass-correlation": "https://en.wikipedia.org/wiki/Intraclass_correlation",
  "linear-regression": "https://en.wikipedia.org/wiki/Linear_regression",
  "multiple-regression": "https://en.wikipedia.org/wiki/Linear_regression",
  "logistic-regression": "https://en.wikipedia.org/wiki/Logistic_regression",
  "poisson-regression": "https://en.wikipedia.org/wiki/Poisson_regression",
  "negative-binomial": "https://en.wikipedia.org/wiki/Negative_binomial_regression",
  "ordinal-regression": "https://en.wikipedia.org/wiki/Ordinal_regression",
  "probit-regression": "https://en.wikipedia.org/wiki/Probit_model",
  "quantile-regression": "https://en.wikipedia.org/wiki/Quantile_regression",
  "robust-regression": "https://en.wikipedia.org/wiki/Robust_regression",
  "elastic-net": "https://en.wikipedia.org/wiki/Elastic_net_regularization",
  "lasso-ridge": "https://en.wikipedia.org/wiki/Regularization_(mathematics)#Regression",
  "bayesian-regression": "https://en.wikipedia.org/wiki/Bayesian_linear_regression",
  "chi-square": "https://en.wikipedia.org/wiki/Chi-squared_test",
  "fisher-exact": "https://en.wikipedia.org/wiki/Fisher%27s_exact_test",
  "mcnemar-test": "https://en.wikipedia.org/wiki/McNemar%27s_test",
  "cochran-q": "https://en.wikipedia.org/wiki/Cochran%27s_Q_test",
  "cramers-v": "https://en.wikipedia.org/wiki/Cram%C3%A9r%27s_V",
  "cohens-kappa": "https://en.wikipedia.org/wiki/Cohen%27s_kappa",
  "fleiss-kappa": "https://en.wikipedia.org/wiki/Fleiss%27_kappa",
  "odds-ratio": "https://en.wikipedia.org/wiki/Odds_ratio",
  "linear-mixed-model": "https://en.wikipedia.org/wiki/Linear_mixed-effects_model",
  "glmm": "https://en.wikipedia.org/wiki/Generalized_linear_mixed_model",
  "arima": "https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average",
  "exponential-smoothing": "https://en.wikipedia.org/wiki/Exponential_smoothing",
  "var": "https://en.wikipedia.org/wiki/Vector_autoregression",
  "ljung-box": "https://en.wikipedia.org/wiki/Ljung%E2%80%93Box_test",
  "adf-test": "https://en.wikipedia.org/wiki/Augmented_Dickey%E2%80%93Fuller_test",
  "granger-causality": "https://en.wikipedia.org/wiki/Granger_causality",
  "prophet": "https://en.wikipedia.org/wiki/Prophet_(software)",
  "kaplan-meier": "https://en.wikipedia.org/wiki/Kaplan%E2%80%93Meier_estimator",
  "log-rank-test": "https://en.wikipedia.org/wiki/Logrank_test",
  "cox-regression": "https://en.wikipedia.org/wiki/Proportional_hazards_model",
  "accelerated-failure-time": "https://en.wikipedia.org/wiki/Accelerated_failure_time_model",
  "competing-risks": "https://en.wikipedia.org/wiki/Competing_risks",
  "random-survival-forest": "https://en.wikipedia.org/wiki/Survival_analysis",
  "kmeans": "https://en.wikipedia.org/wiki/K-means_clustering",
  "hierarchical-clustering": "https://en.wikipedia.org/wiki/Hierarchical_clustering",
  "dbscan": "https://en.wikipedia.org/wiki/DBSCAN",
  "gaussian-mixture": "https://en.wikipedia.org/wiki/Mixture_model",
  "pca": "https://en.wikipedia.org/wiki/Principal_component_analysis",
  "factor-analysis": "https://en.wikipedia.org/wiki/Factor_analysis",
  "tsne": "https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding",
  "umap": "https://en.wikipedia.org/wiki/UMAP",
  "random-forest": "https://en.wikipedia.org/wiki/Random_forest",
  "gradient-boosting": "https://en.wikipedia.org/wiki/Gradient_boosting",
  "svm": "https://en.wikipedia.org/wiki/Support-vector_machine",
  "knn": "https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm",
  "naive-bayes": "https://en.wikipedia.org/wiki/Naive_Bayes_classifier",
  "decision-tree": "https://en.wikipedia.org/wiki/Decision_tree_learning",
  "neural-network-mlp": "https://en.wikipedia.org/wiki/Multilayer_perceptron",
  "xgboost": "https://en.wikipedia.org/wiki/XGBoost",
  "lightgbm": "https://en.wikipedia.org/wiki/LightGBM",
  "catboost": "https://en.wikipedia.org/wiki/CatBoost",
  "random-survival-forest-ml": "https://en.wikipedia.org/wiki/Survival_analysis",
  "bootstrap": "https://en.wikipedia.org/wiki/Bootstrapping_(statistics)",
  "permutation-test": "https://en.wikipedia.org/wiki/Permutation_test",
  "power-analysis": "https://en.wikipedia.org/wiki/Statistical_power",
  "levene-test": "https://en.wikipedia.org/wiki/Levene%27s_test",
  "bartlett-test": "https://en.wikipedia.org/wiki/Bartlett%27s_test",
  "brown-forsythe": "https://en.wikipedia.org/wiki/Brown%E2%80%93Forsythe_test",
  "fligner-killeen": "https://en.wikipedia.org/wiki/Fligner%E2%80%93Killeen_test",
  "hartley-fmax": "https://en.wikipedia.org/wiki/Hartley%27s_test",
  "shapiro-wilk": "https://en.wikipedia.org/wiki/Shapiro%E2%80%93Wilk_test",
  "kolmogorov-smirnov": "https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test",
  "anderson-darling": "https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test",
  "dagostino-pearson": "https://en.wikipedia.org/wiki/D%27Agostino%27s_K-squared_test",
  "durbin-watson": "https://en.wikipedia.org/wiki/Durbin%E2%80%93Watson_statistic",
  "breusch-pagan": "https://en.wikipedia.org/wiki/Breusch%E2%80%93Pagan_test",
  "vif": "https://en.wikipedia.org/wiki/Variance_inflation_factor",
  "tukey-hsd": "https://en.wikipedia.org/wiki/Tukey%27s_range_test",
  "bonferroni": "https://en.wikipedia.org/wiki/Bonferroni_correction",
  "holm-bonferroni": "https://en.wikipedia.org/wiki/Holm%E2%80%93Bonferroni_method",
  "benjamini-hochberg": "https://en.wikipedia.org/wiki/False_discovery_rate",
  "dunnett-test": "https://en.wikipedia.org/wiki/Dunnett%27s_test",
  "scheffe-test": "https://en.wikipedia.org/wiki/Scheff%C3%A9%27s_method",
  "games-howell": "https://en.wikipedia.org/wiki/Post_hoc_analysis",
  "dunn-test": "https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_test",
  "welch-t-test": "https://en.wikipedia.org/wiki/Welch%27s_t-test",
  "welch-anova": "https://en.wikipedia.org/wiki/Welch%27s_ANOVA",
  "ancova": "https://en.wikipedia.org/wiki/Analysis_of_covariance",
  "manova": "https://en.wikipedia.org/wiki/Multivariate_analysis_of_variance",
  "bayesian-t-test": "https://en.wikipedia.org/wiki/Bayes_factor",
  "bayesian-anova": "https://en.wikipedia.org/wiki/Bayesian_statistics",
  "cohens-d": "https://en.wikipedia.org/wiki/Effect_size#Cohen%27s_d",
  "hedges-g": "https://en.wikipedia.org/wiki/Effect_size#Hedges%27_g",
  "eta-squared": "https://en.wikipedia.org/wiki/Effect_size#Eta-squared",
};

export function getWikipediaUrl(testId: string): string | null {
  return wikipediaUrls[testId] || null;
}

export const wizardSteps: WizardStep[] = [
  {
    id: "research-goal",
    title: "Research Goal",
    question: "What is your primary research goal?",
    options: [
      { value: "estimate", label: "Estimate a parameter", description: "Confidence intervals, point estimates" },
      { value: "compare", label: "Compare groups", description: "Test differences between two or more groups" },
      { value: "relationship", label: "Assess relationships", description: "Correlation, association between variables" },
      { value: "predict", label: "Predict outcomes", description: "Regression, classification models" },
      { value: "independence", label: "Test independence / association", description: "Chi-square tests, contingency tables" },
      { value: "time", label: "Model time or sequential structure", description: "Time series, survival analysis" },
      { value: "unsupervised", label: "Discover patterns (unsupervised)", description: "Clustering, dimension reduction" },
      { value: "power", label: "Plan sample size / power", description: "Power analysis, sample size calculation" },
    ],
  },
  {
    id: "outcome-type",
    title: "Outcome Type",
    question: "What type of outcome variable do you have?",
    options: [
      { value: "continuous", label: "Numeric (continuous)", description: "Measurements like height, weight, temperature" },
      { value: "counts", label: "Numeric (counts/rates)", description: "Count data like number of events" },
      { value: "ordinal", label: "Ordinal", description: "Ranked categories like Likert scales" },
      { value: "categorical", label: "Categorical (nominal)", description: "Unordered categories like colors, types" },
      { value: "binary", label: "Binary", description: "Two outcomes like yes/no, success/failure" },
      { value: "time-to-event", label: "Time-to-event", description: "Survival data with censoring" },
      { value: "multivariate", label: "Multivariate", description: "Multiple outcome variables" },
      { value: "high-dimensional", label: "High-dimensional (p >> n)", description: "More variables than observations" },
      { value: "text", label: "Text data", description: "Natural language, documents" },
    ],
  },
  {
    id: "sample-structure",
    title: "Sample Structure",
    question: "What is your sample structure?",
    options: [
      { value: "independent", label: "Independent samples", description: "Different subjects in each group" },
      { value: "paired", label: "Paired/matched samples", description: "Same subjects measured twice or matched pairs" },
      { value: "clustered", label: "Clustered/hierarchical", description: "Nested data like students in schools" },
      { value: "longitudinal", label: "Longitudinal/repeated measures", description: "Multiple measurements over time" },
      { value: "time-series", label: "Time series", description: "Sequential observations over time" },
      { value: "spatial", label: "Spatially indexed data", description: "Geographic or spatial locations" },
    ],
  },
  {
    id: "study-design",
    title: "Study Design",
    question: "What type of study design are you using?",
    options: [
      { value: "randomized", label: "Randomized experiment", description: "Random assignment to groups" },
      { value: "blocking", label: "Blocking/factorial design", description: "Controlled experimental design" },
      { value: "crossover", label: "Crossover design", description: "Subjects receive all treatments" },
      { value: "cross-sectional", label: "Cross-sectional observational", description: "Single time point observation" },
      { value: "case-control", label: "Case-control", description: "Compare cases vs controls retrospectively" },
      { value: "cohort", label: "Cohort", description: "Follow groups over time" },
    ],
  },
  {
    id: "assumptions",
    title: "Assumptions",
    question: "What assumptions can your data meet?",
    options: [
      { value: "parametric", label: "Parametric assumptions met", description: "Normal distribution, equal variances, linearity" },
      { value: "nonparametric", label: "Need non-parametric methods", description: "Skewed data, ordinal outcomes, small samples" },
      { value: "robust", label: "Need robust/outlier-resistant", description: "Data has outliers or heavy tails" },
      { value: "bayesian", label: "Prefer Bayesian approach", description: "Prior information, uncertainty quantification" },
      { value: "unsure", label: "Not sure", description: "Will provide recommendations for multiple approaches" },
    ],
  },
];

export const statisticalTests: StatTest[] = [
  // Group Comparison - Parametric
  {
    id: "t-test-independent",
    name: "Independent Samples t-Test",
    description: "Compares means of two independent groups to determine if they are statistically different.",
    assumptions: ["Normal distribution in each group", "Equal variances (can be relaxed with Welch's t-test)", "Independent observations", "Continuous outcome"],
    whenToUse: ["Comparing two independent group means", "Sample size > 30 per group (or normally distributed)", "Continuous outcome variable"],
    alternatives: ["Mann-Whitney U test (non-parametric)", "Welch's t-test (unequal variances)"],
    methodFamily: "Parametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["mann-whitney", "welch-t-test", "bayesian-t-test"],
  },
  {
    id: "paired-t-test",
    name: "Paired Samples t-Test",
    description: "Compares means from the same group at two different times or under two different conditions.",
    assumptions: ["Differences are normally distributed", "Paired/matched observations", "Continuous outcome"],
    whenToUse: ["Before-after comparisons", "Matched pairs design", "Crossover studies"],
    alternatives: ["Wilcoxon signed-rank test (non-parametric)"],
    methodFamily: "Parametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "paired/repeated measures",
    level: "basic",
    alternativeLinks: ["wilcoxon-signed-rank"],
  },
  {
    id: "one-way-anova",
    name: "One-Way ANOVA",
    description: "Tests whether there are statistically significant differences between the means of three or more independent groups.",
    assumptions: ["Normal distribution in each group", "Equal variances (homoscedasticity)", "Independent observations"],
    whenToUse: ["Comparing 3+ group means", "One categorical predictor", "Continuous outcome"],
    alternatives: ["Kruskal-Wallis H test (non-parametric)", "Welch's ANOVA (unequal variances)"],
    methodFamily: "Parametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["kruskal-wallis", "welch-anova", "bayesian-anova"],
  },
  {
    id: "two-way-anova",
    name: "Two-Way ANOVA",
    description: "Tests the effect of two independent categorical variables on a continuous outcome, including their interaction.",
    assumptions: ["Normal distribution", "Equal variances", "Independent observations", "No significant outliers"],
    whenToUse: ["Two categorical predictors", "Factorial experimental design", "Testing interaction effects"],
    alternatives: ["Robust ANOVA", "Aligned ranks transformation"],
    methodFamily: "Parametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "continuous",
    predictorStructure: "multiple categorical",
    design: "factorial",
    level: "intermediate",
    alternativeLinks: ["linear-mixed-model", "manova"],
  },
  {
    id: "repeated-measures-anova",
    name: "Repeated Measures ANOVA",
    description: "Tests differences across multiple time points or conditions for the same subjects.",
    assumptions: ["Sphericity", "Normal distribution", "No significant outliers"],
    whenToUse: ["Multiple measurements on same subjects", "Longitudinal within-subject design", "Before-during-after comparisons"],
    alternatives: ["Friedman test (non-parametric)", "Mixed-effects models"],
    methodFamily: "Parametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "paired/repeated measures",
    level: "intermediate",
    alternativeLinks: ["friedman-test", "linear-mixed-model"],
  },
  // Group Comparison - Non-parametric
  {
    id: "mann-whitney",
    name: "Mann-Whitney U Test",
    description: "Non-parametric test that compares distributions of two independent groups.",
    assumptions: ["Independent samples", "Ordinal or continuous outcome", "Similar distribution shapes"],
    whenToUse: ["Non-normal distributions", "Ordinal data", "Small sample sizes"],
    alternatives: ["Independent t-test (parametric)"],
    methodFamily: "Nonparametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "ordinal",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["t-test-independent", "permutation-test"],
  },
  {
    id: "wilcoxon-signed-rank",
    name: "Wilcoxon Signed-Rank Test",
    description: "Non-parametric test for comparing two related samples or repeated measurements.",
    assumptions: ["Paired observations", "Ordinal or continuous outcome", "Symmetric distribution of differences"],
    whenToUse: ["Paired data with non-normal differences", "Ordinal outcomes", "Before-after comparisons"],
    alternatives: ["Paired t-test (parametric)"],
    methodFamily: "Nonparametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "ordinal",
    predictorStructure: "single categorical",
    design: "paired/repeated measures",
    level: "basic",
    alternativeLinks: ["paired-t-test"],
  },
  {
    id: "kruskal-wallis",
    name: "Kruskal-Wallis H Test",
    description: "Non-parametric alternative to one-way ANOVA for comparing three or more independent groups.",
    assumptions: ["Independent samples", "Ordinal or continuous outcome", "Similar distribution shapes"],
    whenToUse: ["Comparing 3+ groups with non-normal data", "Ordinal outcomes", "Unequal group sizes"],
    alternatives: ["One-way ANOVA (parametric)"],
    methodFamily: "Nonparametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "ordinal",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["one-way-anova", "dunn-test"],
  },
  {
    id: "friedman-test",
    name: "Friedman Test",
    description: "Non-parametric alternative to repeated measures ANOVA for ordinal or non-normal data.",
    assumptions: ["Related samples", "Ordinal or continuous outcome", "Same subjects across conditions"],
    whenToUse: ["Repeated measures with non-normal data", "Ordinal outcomes", "Blocked designs"],
    alternatives: ["Repeated measures ANOVA (parametric)"],
    methodFamily: "Nonparametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "ordinal",
    predictorStructure: "single categorical",
    design: "paired/repeated measures",
    level: "intermediate",
    alternativeLinks: ["repeated-measures-anova"],
  },
  // Relationship/Correlation
  {
    id: "pearson-correlation",
    name: "Pearson Correlation",
    description: "Measures the linear relationship between two continuous variables.",
    assumptions: ["Linear relationship", "Bivariate normality", "No outliers", "Continuous variables"],
    whenToUse: ["Measuring linear association", "Both variables continuous", "Normally distributed data"],
    alternatives: ["Spearman correlation (non-parametric)", "Kendall's tau (ordinal)"],
    methodFamily: "Parametric",
    category: "Correlation",
    categoryId: "correlation",
    outcomeScale: "continuous",
    predictorStructure: "single continuous",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["spearman-correlation", "kendall-tau"],
  },
  {
    id: "spearman-correlation",
    name: "Spearman Rank Correlation",
    description: "Non-parametric measure of monotonic relationship between two variables.",
    assumptions: ["Monotonic relationship", "Ordinal or continuous data", "Independent observations"],
    whenToUse: ["Non-linear monotonic relationships", "Ordinal data", "Outliers present"],
    alternatives: ["Pearson correlation (parametric)", "Kendall's tau"],
    methodFamily: "Nonparametric",
    category: "Correlation",
    categoryId: "correlation",
    outcomeScale: "ordinal",
    predictorStructure: "single continuous",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["pearson-correlation", "kendall-tau"],
  },
  {
    id: "partial-correlation",
    name: "Partial Correlation",
    description: "Measures association between two variables while controlling for one or more other variables.",
    assumptions: ["Linear relationships", "No multicollinearity", "Continuous variables"],
    whenToUse: ["Controlling for confounders", "Isolating relationships", "Multiple predictors"],
    alternatives: ["Multiple regression", "Path analysis"],
    methodFamily: "Parametric",
    category: "Correlation",
    categoryId: "correlation",
    outcomeScale: "continuous",
    predictorStructure: "multiple continuous",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["multiple-regression"],
  },
  // Regression
  {
    id: "linear-regression",
    name: "Linear Regression",
    description: "Models the relationship between a continuous outcome and one or more predictors.",
    assumptions: ["Linear relationship", "Normal residuals", "Homoscedasticity", "Independence of errors"],
    whenToUse: ["Predicting continuous outcomes", "Multiple predictors", "Quantifying relationships"],
    alternatives: ["Robust regression (outliers)", "Quantile regression"],
    methodFamily: "Regression-based",
    category: "Regression",
    categoryId: "regression",
    outcomeScale: "continuous",
    predictorStructure: "single continuous",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["multiple-regression", "robust-regression", "bayesian-regression"],
  },
  {
    id: "multiple-regression",
    name: "Multiple Linear Regression",
    description: "Models relationship between continuous outcome and multiple predictors simultaneously.",
    assumptions: ["Linear relationships", "Normal residuals", "No multicollinearity", "Homoscedasticity"],
    whenToUse: ["Multiple predictors", "Controlling for confounders", "Prediction with covariates"],
    alternatives: ["Ridge/Lasso regression", "Partial least squares"],
    methodFamily: "Regression-based",
    category: "Regression",
    categoryId: "regression",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["linear-regression", "lasso-ridge", "elastic-net"],
  },
  {
    id: "logistic-regression",
    name: "Logistic Regression",
    description: "Models the probability of a binary outcome based on one or more predictors.",
    assumptions: ["Binary outcome", "Independence of observations", "No multicollinearity", "Linear relationship with log-odds"],
    whenToUse: ["Binary classification", "Odds ratio estimation", "Multiple predictors"],
    alternatives: ["Probit regression", "Discriminant analysis"],
    methodFamily: "Regression-based",
    category: "Regression",
    categoryId: "regression",
    outcomeScale: "binary",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["probit-regression", "random-forest", "svm"],
  },
  {
    id: "poisson-regression",
    name: "Poisson Regression",
    description: "Models count data as a function of predictors, assuming counts follow a Poisson distribution.",
    assumptions: ["Count outcome", "Mean equals variance", "Independence", "Log-linear relationship"],
    whenToUse: ["Count outcomes", "Rate data", "Event frequencies"],
    alternatives: ["Negative binomial regression (overdispersion)", "Zero-inflated models"],
    methodFamily: "Regression-based",
    category: "Regression",
    categoryId: "regression",
    outcomeScale: "count",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["negative-binomial", "zero-inflated-poisson"],
  },
  {
    id: "ordinal-regression",
    name: "Ordinal Logistic Regression",
    description: "Models ordinal outcomes with three or more ordered categories.",
    assumptions: ["Ordinal outcome", "Proportional odds", "Independence"],
    whenToUse: ["Ordinal outcomes (Likert scales)", "Ranked categories", "Multiple predictors"],
    alternatives: ["Multinomial regression", "Cumulative link models"],
    methodFamily: "Regression-based",
    category: "Regression",
    categoryId: "regression",
    outcomeScale: "ordinal",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["logistic-regression", "multinomial-logistic"],
  },
  // Categorical Analysis
  {
    id: "chi-square",
    name: "Chi-Square Test of Independence",
    description: "Tests whether there is a significant association between two categorical variables.",
    assumptions: ["Expected cell count >= 5 in 80% of cells", "Independent observations", "Categorical variables"],
    whenToUse: ["Testing association between categorical variables", "Contingency tables", "Independence testing"],
    alternatives: ["Fisher's exact test (small samples)"],
    methodFamily: "Nonparametric",
    category: "Categorical",
    categoryId: "categorical",
    outcomeScale: "nominal",
    predictorStructure: "single categorical",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["fisher-exact", "cramers-v"],
  },
  {
    id: "fisher-exact",
    name: "Fisher's Exact Test",
    description: "Exact test for association in 2x2 contingency tables, especially with small samples.",
    assumptions: ["2x2 table", "Fixed marginals", "Independent observations"],
    whenToUse: ["Small sample sizes", "Expected counts < 5", "2x2 tables"],
    alternatives: ["Chi-square test (larger samples)"],
    methodFamily: "Nonparametric",
    category: "Categorical",
    categoryId: "categorical",
    outcomeScale: "nominal",
    predictorStructure: "single categorical",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["chi-square"],
  },
  {
    id: "mcnemar-test",
    name: "McNemar's Test",
    description: "Tests for differences in paired proportions or matched case-control studies.",
    assumptions: ["Paired binary data", "Matched samples", "Sufficient discordant pairs"],
    whenToUse: ["Before-after binary outcomes", "Matched pairs", "Diagnostic test comparison"],
    alternatives: ["Cochran's Q test (3+ conditions)"],
    methodFamily: "Nonparametric",
    category: "Categorical",
    categoryId: "categorical",
    outcomeScale: "binary",
    predictorStructure: "single categorical",
    design: "paired/repeated measures",
    level: "intermediate",
    alternativeLinks: ["cochran-q"],
  },
  // Mixed/Multilevel Models
  {
    id: "linear-mixed-model",
    name: "Linear Mixed Model",
    description: "Models continuous outcomes with both fixed and random effects for hierarchical/clustered data.",
    assumptions: ["Normal residuals", "Linear relationships", "Random effects normally distributed"],
    whenToUse: ["Clustered/nested data", "Repeated measures", "Unbalanced designs"],
    alternatives: ["Generalized estimating equations", "Hierarchical Bayesian models"],
    methodFamily: "Mixed Models",
    category: "Mixed Models",
    categoryId: "mixed",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    level: "advanced",
    alternativeLinks: ["glmm", "repeated-measures-anova"],
  },
  {
    id: "glmm",
    name: "Generalized Linear Mixed Model",
    description: "Extends GLM to include random effects for non-normal outcomes with clustering.",
    assumptions: ["Appropriate link function", "Random effects specification", "Conditional independence"],
    whenToUse: ["Non-normal outcomes with clustering", "Binary/count data in hierarchical structures"],
    alternatives: ["GEE", "Bayesian hierarchical models"],
    methodFamily: "Mixed Models",
    category: "Mixed Models",
    categoryId: "mixed",
    outcomeScale: "binary",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    level: "advanced",
    alternativeLinks: ["linear-mixed-model", "gee"],
  },
  // Time Series
  {
    id: "arima",
    name: "ARIMA Model",
    description: "Autoregressive integrated moving average model for time series forecasting.",
    assumptions: ["Stationarity (after differencing)", "No seasonality (or use SARIMA)", "Constant variance"],
    whenToUse: ["Time series forecasting", "Trend modeling", "Autocorrelated data"],
    alternatives: ["Exponential smoothing", "Prophet", "State-space models"],
    methodFamily: "Time-series",
    category: "Time Series",
    categoryId: "time-series",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "time-series",
    level: "intermediate",
    alternativeLinks: ["exponential-smoothing", "prophet", "var"],
  },
  {
    id: "exponential-smoothing",
    name: "Exponential Smoothing",
    description: "Weighted moving average methods for time series forecasting with trend and seasonality.",
    assumptions: ["Regular time intervals", "Stationary error variance"],
    whenToUse: ["Short-term forecasting", "Trend and seasonality", "Simpler interpretation"],
    alternatives: ["ARIMA", "Theta method"],
    methodFamily: "Time-series",
    category: "Time Series",
    categoryId: "time-series",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "time-series",
    level: "intermediate",
    alternativeLinks: ["arima", "prophet"],
  },
  // Survival Analysis
  {
    id: "kaplan-meier",
    name: "Kaplan-Meier Estimator",
    description: "Non-parametric estimator of survival function from time-to-event data.",
    assumptions: ["Independent censoring", "Well-defined time origin", "No competing risks (or adjust)"],
    whenToUse: ["Estimating survival curves", "Handling censored data", "Descriptive survival analysis"],
    alternatives: ["Nelson-Aalen estimator", "Parametric survival models"],
    methodFamily: "Survival",
    category: "Survival Analysis",
    categoryId: "survival",
    outcomeScale: "time-to-event",
    predictorStructure: "none",
    design: "longitudinal",
    level: "intermediate",
    alternativeLinks: ["log-rank-test", "cox-regression"],
  },
  {
    id: "log-rank-test",
    name: "Log-Rank Test",
    description: "Compares survival distributions between two or more groups.",
    assumptions: ["Proportional hazards", "Independent censoring", "Non-informative censoring"],
    whenToUse: ["Comparing survival curves", "Clinical trial endpoints", "Time-to-event comparisons"],
    alternatives: ["Wilcoxon-Gehan test", "Cox regression"],
    methodFamily: "Survival",
    category: "Survival Analysis",
    categoryId: "survival",
    outcomeScale: "time-to-event",
    predictorStructure: "single categorical",
    design: "longitudinal",
    level: "intermediate",
    alternativeLinks: ["kaplan-meier", "cox-regression"],
  },
  {
    id: "cox-regression",
    name: "Cox Proportional Hazards",
    description: "Semi-parametric regression model for time-to-event data with covariates.",
    assumptions: ["Proportional hazards", "Independent censoring", "Linear covariate effects on log-hazard"],
    whenToUse: ["Survival with covariates", "Hazard ratio estimation", "Adjusting for confounders"],
    alternatives: ["Accelerated failure time models", "Parametric survival models"],
    methodFamily: "Survival",
    category: "Survival Analysis",
    categoryId: "survival",
    outcomeScale: "time-to-event",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    level: "advanced",
    alternativeLinks: ["kaplan-meier", "accelerated-failure-time", "random-survival-forest"],
  },
  // Unsupervised Learning
  {
    id: "kmeans",
    name: "K-Means Clustering",
    description: "Partitions observations into k clusters by minimizing within-cluster variance.",
    assumptions: ["Spherical clusters", "Similar cluster sizes", "Numeric features"],
    whenToUse: ["Finding natural groupings", "Customer segmentation", "Pattern discovery"],
    alternatives: ["Hierarchical clustering", "DBSCAN", "Gaussian mixtures"],
    methodFamily: "Machine Learning",
    category: "Clustering",
    categoryId: "clustering",
    outcomeScale: "multivariate",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["hierarchical-clustering", "dbscan", "gaussian-mixture"],
  },
  {
    id: "hierarchical-clustering",
    name: "Hierarchical Clustering",
    description: "Builds a tree of clusters using agglomerative or divisive approaches.",
    assumptions: ["Meaningful distance metric", "Appropriate linkage method"],
    whenToUse: ["Exploring cluster hierarchy", "Dendrogram visualization", "Unknown number of clusters"],
    alternatives: ["K-means", "DBSCAN"],
    methodFamily: "Machine Learning",
    category: "Clustering",
    categoryId: "clustering",
    outcomeScale: "multivariate",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["kmeans", "dbscan"],
  },
  {
    id: "pca",
    name: "Principal Component Analysis",
    description: "Reduces dimensionality by finding orthogonal directions of maximum variance.",
    assumptions: ["Linear relationships", "Continuous variables", "Standardized features"],
    whenToUse: ["Dimension reduction", "Feature extraction", "Visualization of high-dimensional data"],
    alternatives: ["Factor analysis", "t-SNE", "UMAP"],
    methodFamily: "Multivariate",
    category: "Dimension Reduction",
    categoryId: "dimension",
    outcomeScale: "multivariate",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["factor-analysis", "tsne", "umap"],
  },
  {
    id: "factor-analysis",
    name: "Factor Analysis",
    description: "Identifies latent factors underlying observed variables.",
    assumptions: ["Linear relationships", "Multivariate normality", "Sufficient sample size"],
    whenToUse: ["Scale development", "Latent construct identification", "Data reduction with theory"],
    alternatives: ["PCA", "Structural equation modeling"],
    methodFamily: "Multivariate",
    category: "Dimension Reduction",
    categoryId: "dimension",
    outcomeScale: "multivariate",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["pca"],
  },
  // Machine Learning
  {
    id: "random-forest",
    name: "Random Forest",
    description: "Ensemble of decision trees for classification or regression with improved accuracy.",
    assumptions: ["No strict distributional assumptions", "Sufficient training data"],
    whenToUse: ["Complex non-linear relationships", "Feature importance", "Robust predictions"],
    alternatives: ["Gradient boosting", "Single decision tree", "Neural networks"],
    methodFamily: "Machine Learning",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["gradient-boosting", "xgboost", "decision-tree"],
  },
  {
    id: "gradient-boosting",
    name: "Gradient Boosting",
    description: "Sequentially builds weak learners to minimize prediction errors.",
    assumptions: ["Sufficient training data", "Proper hyperparameter tuning"],
    whenToUse: ["High prediction accuracy", "Structured/tabular data", "Competitions"],
    alternatives: ["Random forest", "XGBoost", "LightGBM"],
    methodFamily: "Machine Learning",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["random-forest", "xgboost", "lightgbm"],
  },
  {
    id: "lasso-ridge",
    name: "Lasso/Ridge Regression",
    description: "Regularized regression methods that shrink coefficients to prevent overfitting.",
    assumptions: ["Linear relationships", "Standardized predictors recommended"],
    whenToUse: ["High-dimensional data", "Multicollinearity", "Variable selection (Lasso)"],
    alternatives: ["Elastic net", "Principal components regression"],
    methodFamily: "Regression-based",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "continuous",
    predictorStructure: "multiple continuous",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["elastic-net", "multiple-regression"],
  },
  // Resampling/Bootstrap
  {
    id: "bootstrap",
    name: "Bootstrap",
    description: "Resampling method to estimate sampling distributions and confidence intervals.",
    assumptions: ["Representative sample", "Independent observations"],
    whenToUse: ["Unknown sampling distribution", "Complex statistics", "Small samples"],
    alternatives: ["Jackknife", "Permutation tests"],
    methodFamily: "Resampling",
    category: "Resampling",
    categoryId: "resampling",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["permutation-test"],
  },
  {
    id: "permutation-test",
    name: "Permutation Test",
    description: "Non-parametric test using random permutations to generate null distribution.",
    assumptions: ["Exchangeability under null", "Independent observations"],
    whenToUse: ["No distributional assumptions", "Small samples", "Complex test statistics"],
    alternatives: ["Bootstrap", "Parametric tests"],
    methodFamily: "Permutation-based",
    category: "Resampling",
    categoryId: "resampling",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["bootstrap", "mann-whitney"],
  },
  // Power Analysis
  {
    id: "power-analysis",
    name: "Power Analysis",
    description: "Calculates required sample size or statistical power for detecting an effect.",
    assumptions: ["Specified effect size", "Known alpha level", "Appropriate test selection"],
    whenToUse: ["Study planning", "Grant applications", "Sample size justification"],
    alternatives: ["Simulation-based power", "Bayesian sample size"],
    methodFamily: "Planning",
    category: "Study Planning",
    categoryId: "planning",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: [],
  },
  
  // === ASSUMPTION & DIAGNOSTIC TESTS ===
  // Equal Variance Tests
  {
    id: "levene-test",
    name: "Levene's Test",
    description: "Tests the null hypothesis that all groups have equal variances. More robust to non-normality than Bartlett's test.",
    assumptions: ["Independent samples", "Continuous or ordinal data"],
    whenToUse: ["Checking homogeneity of variance before ANOVA", "Non-normal data", "Robust variance testing"],
    alternatives: ["Bartlett's test (normal data)", "Brown-Forsythe test", "Fligner-Killeen test"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["bartlett-test", "brown-forsythe", "fligner-killeen"],
  },
  {
    id: "bartlett-test",
    name: "Bartlett's Test",
    description: "Tests equality of variances across groups, sensitive to departures from normality.",
    assumptions: ["Normal distribution in each group", "Independent samples"],
    whenToUse: ["Variance homogeneity testing", "Normally distributed data", "Before ANOVA"],
    alternatives: ["Levene's test (non-normal)", "Brown-Forsythe test"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["levene-test", "brown-forsythe"],
  },
  {
    id: "brown-forsythe",
    name: "Brown-Forsythe Test",
    description: "Robust test for equality of variances using deviations from group medians.",
    assumptions: ["Independent samples", "Continuous data"],
    whenToUse: ["Variance testing with skewed data", "Outlier-resistant variance comparison"],
    alternatives: ["Levene's test", "Bartlett's test"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["levene-test", "bartlett-test"],
  },
  {
    id: "fligner-killeen",
    name: "Fligner-Killeen Test",
    description: "Non-parametric test for homogeneity of variances, highly robust to non-normality.",
    assumptions: ["Independent samples", "Ordinal or continuous data"],
    whenToUse: ["Severe non-normality", "Robust variance testing", "Small samples"],
    alternatives: ["Levene's test", "Bartlett's test"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["levene-test"],
  },
  {
    id: "hartley-fmax",
    name: "Hartley's F-max Test",
    description: "Quick test for variance homogeneity using ratio of largest to smallest group variance.",
    assumptions: ["Equal sample sizes", "Normal distribution", "Independent samples"],
    whenToUse: ["Quick variance ratio check", "Balanced designs", "Preliminary analysis"],
    alternatives: ["Levene's test", "Bartlett's test"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["levene-test", "bartlett-test"],
  },
  // Normality Tests
  {
    id: "shapiro-wilk",
    name: "Shapiro-Wilk Test",
    description: "Tests whether a sample comes from a normally distributed population. Considered one of the most powerful normality tests.",
    assumptions: ["Sample size typically between 3-5000", "Independent observations"],
    whenToUse: ["Checking normality assumption", "Small to moderate samples", "Before parametric tests"],
    alternatives: ["Kolmogorov-Smirnov", "Anderson-Darling", "D'Agostino-Pearson"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["kolmogorov-smirnov", "anderson-darling", "dagostino-pearson"],
  },
  {
    id: "kolmogorov-smirnov",
    name: "Kolmogorov-Smirnov Test",
    description: "Compares sample distribution to a reference distribution (often normal) or compares two samples.",
    assumptions: ["Continuous distribution", "Independent observations"],
    whenToUse: ["Testing any distributional assumption", "Comparing two distributions", "Large samples"],
    alternatives: ["Shapiro-Wilk (normality)", "Anderson-Darling"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["shapiro-wilk", "anderson-darling"],
  },
  {
    id: "anderson-darling",
    name: "Anderson-Darling Test",
    description: "Tests whether a sample comes from a specified distribution, with more weight on tails than KS test.",
    assumptions: ["Continuous distribution", "Known reference distribution"],
    whenToUse: ["Normality testing with tail sensitivity", "Distribution fitting", "Quality control"],
    alternatives: ["Shapiro-Wilk", "Kolmogorov-Smirnov"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["shapiro-wilk", "kolmogorov-smirnov"],
  },
  {
    id: "dagostino-pearson",
    name: "D'Agostino-Pearson Test",
    description: "Omnibus test combining skewness and kurtosis to test for normality.",
    assumptions: ["Sample size > 20", "Independent observations"],
    whenToUse: ["Moderate to large samples", "Detecting non-normality from skewness/kurtosis"],
    alternatives: ["Shapiro-Wilk", "Jarque-Bera"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["shapiro-wilk"],
  },
  // Regression Diagnostics
  {
    id: "durbin-watson",
    name: "Durbin-Watson Test",
    description: "Tests for autocorrelation in residuals from regression analysis.",
    assumptions: ["Linear regression model", "First-order autocorrelation"],
    whenToUse: ["Time series regression", "Detecting serial correlation", "Model diagnostics"],
    alternatives: ["Breusch-Godfrey test", "Ljung-Box test"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "time-series",
    level: "intermediate",
    alternativeLinks: ["ljung-box", "breusch-pagan"],
  },
  {
    id: "breusch-pagan",
    name: "Breusch-Pagan Test",
    description: "Tests for heteroscedasticity in regression residuals.",
    assumptions: ["Linear regression model", "Residuals tested against predictors"],
    whenToUse: ["Checking constant variance", "Regression diagnostics", "Before inference"],
    alternatives: ["White's test", "Goldfeld-Quandt test"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["durbin-watson"],
  },
  {
    id: "vif",
    name: "Variance Inflation Factor (VIF)",
    description: "Quantifies multicollinearity in regression by measuring how much variance is inflated.",
    assumptions: ["Multiple regression context", "Linear relationships"],
    whenToUse: ["Detecting multicollinearity", "Variable selection", "Regression diagnostics"],
    alternatives: ["Condition number", "Tolerance", "Correlation matrix"],
    methodFamily: "Diagnostic",
    category: "Assumption Testing",
    categoryId: "assumption",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: [],
  },
  
  // === POST-HOC TESTS ===
  {
    id: "tukey-hsd",
    name: "Tukey's HSD",
    description: "Post-hoc test for pairwise comparisons after ANOVA, controlling family-wise error rate.",
    assumptions: ["Equal sample sizes (approximate)", "Equal variances", "Normal distribution"],
    whenToUse: ["All pairwise comparisons after ANOVA", "Balanced designs", "Conservative control"],
    alternatives: ["Games-Howell (unequal variances)", "Bonferroni", "Scheff√©"],
    methodFamily: "Multiple Comparison",
    category: "Post-hoc Tests",
    categoryId: "posthoc",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["bonferroni", "games-howell", "scheffe-test"],
  },
  {
    id: "bonferroni",
    name: "Bonferroni Correction",
    description: "Simple adjustment for multiple comparisons by dividing alpha by number of tests.",
    assumptions: ["Independent or dependent tests", "Any test statistic"],
    whenToUse: ["Few comparisons", "Conservative correction", "General multiple testing"],
    alternatives: ["Holm-Bonferroni", "Benjamini-Hochberg", "Tukey HSD"],
    methodFamily: "Multiple Comparison",
    category: "Post-hoc Tests",
    categoryId: "posthoc",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["holm-bonferroni", "tukey-hsd", "benjamini-hochberg"],
  },
  {
    id: "holm-bonferroni",
    name: "Holm-Bonferroni Method",
    description: "Step-down procedure that is uniformly more powerful than Bonferroni while controlling FWER.",
    assumptions: ["Any test statistic", "Ordered p-values"],
    whenToUse: ["Multiple comparisons", "More power than Bonferroni", "Sequential testing"],
    alternatives: ["Bonferroni", "Hochberg", "Benjamini-Hochberg"],
    methodFamily: "Multiple Comparison",
    category: "Post-hoc Tests",
    categoryId: "posthoc",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["bonferroni", "benjamini-hochberg"],
  },
  {
    id: "benjamini-hochberg",
    name: "Benjamini-Hochberg (FDR)",
    description: "Controls false discovery rate rather than family-wise error rate, more powerful for many tests.",
    assumptions: ["Independent or positively dependent tests", "Many hypotheses"],
    whenToUse: ["High-throughput testing", "Genomics", "Exploratory analysis"],
    alternatives: ["Bonferroni (FWER)", "q-value", "Storey's method"],
    methodFamily: "Multiple Comparison",
    category: "Post-hoc Tests",
    categoryId: "posthoc",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["bonferroni", "holm-bonferroni"],
  },
  {
    id: "dunnett-test",
    name: "Dunnett's Test",
    description: "Compares multiple treatment groups to a single control group.",
    assumptions: ["Normal distribution", "Equal variances", "One control group"],
    whenToUse: ["Treatment vs control comparisons", "Not comparing treatments", "Drug trials"],
    alternatives: ["Tukey HSD (all pairs)", "Bonferroni"],
    methodFamily: "Multiple Comparison",
    category: "Post-hoc Tests",
    categoryId: "posthoc",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["tukey-hsd"],
  },
  {
    id: "games-howell",
    name: "Games-Howell Test",
    description: "Post-hoc test for unequal variances and/or unequal sample sizes.",
    assumptions: ["Does not assume equal variances", "Normal distribution"],
    whenToUse: ["Heterogeneous variances", "Unequal sample sizes", "After Welch's ANOVA"],
    alternatives: ["Tukey HSD (equal variances)", "Tamhane's T2"],
    methodFamily: "Multiple Comparison",
    category: "Post-hoc Tests",
    categoryId: "posthoc",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["tukey-hsd", "scheffe-test"],
  },
  {
    id: "scheffe-test",
    name: "Scheff√©'s Test",
    description: "Most conservative post-hoc test, allows any linear contrast of means.",
    assumptions: ["Normal distribution", "Equal variances"],
    whenToUse: ["Complex contrasts", "Post-hoc hypothesis generation", "Maximum protection"],
    alternatives: ["Tukey HSD", "Bonferroni"],
    methodFamily: "Multiple Comparison",
    category: "Post-hoc Tests",
    categoryId: "posthoc",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["tukey-hsd", "games-howell"],
  },
  {
    id: "dunn-test",
    name: "Dunn's Test",
    description: "Non-parametric post-hoc test for pairwise comparisons after Kruskal-Wallis.",
    assumptions: ["Ordinal or continuous data", "Independent samples"],
    whenToUse: ["After Kruskal-Wallis", "Non-parametric multiple comparisons"],
    alternatives: ["Conover-Iman test", "Nemenyi test"],
    methodFamily: "Multiple Comparison",
    category: "Post-hoc Tests",
    categoryId: "posthoc",
    outcomeScale: "ordinal",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["kruskal-wallis"],
  },
  
  // === ADDITIONAL GROUP COMPARISON ===
  {
    id: "welch-t-test",
    name: "Welch's t-Test",
    description: "Modification of t-test that does not assume equal variances between groups.",
    assumptions: ["Normal distribution", "Independent samples", "Unequal variances allowed"],
    whenToUse: ["Unequal variances", "Unequal sample sizes", "Default for two-group comparison"],
    alternatives: ["Student's t-test (equal variances)", "Mann-Whitney U"],
    methodFamily: "Parametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["t-test-independent", "mann-whitney"],
  },
  {
    id: "welch-anova",
    name: "Welch's ANOVA",
    description: "Robust alternative to one-way ANOVA when variances are unequal across groups.",
    assumptions: ["Normal distribution", "Independent samples", "Unequal variances allowed"],
    whenToUse: ["Heterogeneous variances", "Unbalanced designs", "Three or more groups"],
    alternatives: ["One-way ANOVA", "Brown-Forsythe ANOVA", "Kruskal-Wallis"],
    methodFamily: "Parametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["one-way-anova", "kruskal-wallis"],
  },
  {
    id: "ancova",
    name: "ANCOVA",
    description: "Analysis of covariance combining ANOVA with regression to control for covariates.",
    assumptions: ["Homogeneity of regression slopes", "Linear relationship with covariate", "Normal residuals"],
    whenToUse: ["Adjusting for confounders", "Pre-test scores as covariate", "Increasing power"],
    alternatives: ["Mixed models", "Multiple regression"],
    methodFamily: "Parametric",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "continuous",
    predictorStructure: "mixed",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["multiple-regression", "linear-mixed-model"],
  },
  {
    id: "manova",
    name: "MANOVA",
    description: "Multivariate ANOVA testing group differences on multiple dependent variables simultaneously.",
    assumptions: ["Multivariate normality", "Homogeneity of covariance matrices", "Independence"],
    whenToUse: ["Multiple related outcomes", "Reducing Type I error", "Examining patterns"],
    alternatives: ["Separate ANOVAs with correction", "Discriminant analysis"],
    methodFamily: "Multivariate",
    category: "Group Comparison",
    categoryId: "comparison",
    outcomeScale: "multivariate",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "advanced",
    alternativeLinks: ["two-way-anova", "discriminant-analysis"],
  },
  
  // === ADDITIONAL CORRELATION ===
  {
    id: "kendall-tau",
    name: "Kendall's Tau",
    description: "Non-parametric measure of rank correlation, more robust than Spearman for small samples.",
    assumptions: ["Ordinal or continuous data", "Independent observations"],
    whenToUse: ["Small samples", "Many tied ranks", "Robust correlation estimate"],
    alternatives: ["Spearman correlation", "Pearson correlation"],
    methodFamily: "Nonparametric",
    category: "Correlation",
    categoryId: "correlation",
    outcomeScale: "ordinal",
    predictorStructure: "single continuous",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["spearman-correlation", "pearson-correlation"],
  },
  {
    id: "point-biserial",
    name: "Point-Biserial Correlation",
    description: "Measures correlation between a continuous variable and a dichotomous variable.",
    assumptions: ["One continuous, one binary variable", "Normal distribution in groups"],
    whenToUse: ["Binary-continuous relationships", "Item analysis", "Effect size for t-test"],
    alternatives: ["Biserial correlation", "Logistic regression"],
    methodFamily: "Parametric",
    category: "Correlation",
    categoryId: "correlation",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["pearson-correlation", "t-test-independent"],
  },
  {
    id: "intraclass-correlation",
    name: "Intraclass Correlation (ICC)",
    description: "Measures reliability or agreement for observations that are organized into groups.",
    assumptions: ["Grouped/clustered data", "Ratio or interval scale"],
    whenToUse: ["Inter-rater reliability", "Test-retest reliability", "Cluster analysis"],
    alternatives: ["Cohen's kappa (categorical)", "Pearson correlation"],
    methodFamily: "Reliability",
    category: "Correlation",
    categoryId: "correlation",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "paired/repeated measures",
    level: "intermediate",
    alternativeLinks: ["cohens-kappa", "linear-mixed-model"],
  },
  
  // === ADDITIONAL CATEGORICAL ===
  {
    id: "cochran-q",
    name: "Cochran's Q Test",
    description: "Extension of McNemar test for comparing three or more matched proportions.",
    assumptions: ["Binary outcome", "Matched samples", "Three or more conditions"],
    whenToUse: ["Repeated measures binary data", "Multiple raters", "Before-during-after binary"],
    alternatives: ["McNemar test (2 conditions)", "Friedman test"],
    methodFamily: "Nonparametric",
    category: "Categorical",
    categoryId: "categorical",
    outcomeScale: "binary",
    predictorStructure: "single categorical",
    design: "paired/repeated measures",
    level: "intermediate",
    alternativeLinks: ["mcnemar-test", "friedman-test"],
  },
  {
    id: "cramers-v",
    name: "Cram√©r's V",
    description: "Measure of association between two categorical variables, normalized chi-square.",
    assumptions: ["Nominal variables", "Contingency table"],
    whenToUse: ["Effect size for chi-square", "Comparing association strength", "Nominal data"],
    alternatives: ["Phi coefficient (2x2)", "Contingency coefficient"],
    methodFamily: "Effect Size",
    category: "Categorical",
    categoryId: "categorical",
    outcomeScale: "nominal",
    predictorStructure: "single categorical",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["chi-square", "cohens-kappa"],
  },
  {
    id: "cohens-kappa",
    name: "Cohen's Kappa",
    description: "Measures agreement between two raters for categorical items, adjusting for chance.",
    assumptions: ["Categorical data", "Two raters", "Same categories"],
    whenToUse: ["Inter-rater reliability", "Diagnostic agreement", "Coding reliability"],
    alternatives: ["Fleiss' kappa (3+ raters)", "ICC (continuous)"],
    methodFamily: "Reliability",
    category: "Categorical",
    categoryId: "categorical",
    outcomeScale: "nominal",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["fleiss-kappa", "intraclass-correlation"],
  },
  {
    id: "fleiss-kappa",
    name: "Fleiss' Kappa",
    description: "Extends Cohen's kappa to measure agreement among three or more raters.",
    assumptions: ["Categorical data", "Multiple raters", "Fixed categories"],
    whenToUse: ["Multiple rater agreement", "Content analysis", "Medical diagnosis"],
    alternatives: ["Cohen's kappa (2 raters)", "Krippendorff's alpha"],
    methodFamily: "Reliability",
    category: "Categorical",
    categoryId: "categorical",
    outcomeScale: "nominal",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["cohens-kappa"],
  },
  
  // === ADDITIONAL REGRESSION ===
  {
    id: "negative-binomial",
    name: "Negative Binomial Regression",
    description: "Models count data with overdispersion (variance greater than mean).",
    assumptions: ["Count outcome", "Overdispersion present", "Log-linear relationship"],
    whenToUse: ["Overdispersed counts", "Zero-inflated alternatives", "Event count modeling"],
    alternatives: ["Poisson regression", "Zero-inflated models", "Quasi-Poisson"],
    methodFamily: "Regression-based",
    category: "Regression",
    categoryId: "regression",
    outcomeScale: "count",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["poisson-regression", "zero-inflated-poisson"],
  },
  {
    id: "zero-inflated-poisson",
    name: "Zero-Inflated Poisson",
    description: "Models count data with excess zeros using a two-part model.",
    assumptions: ["Count outcome", "Excess zeros", "Two processes generating data"],
    whenToUse: ["Many zeros in count data", "Structural and sampling zeros", "Two-stage process"],
    alternatives: ["Negative binomial", "Hurdle models", "Poisson regression"],
    methodFamily: "Regression-based",
    category: "Regression",
    categoryId: "regression",
    outcomeScale: "count",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "advanced",
    alternativeLinks: ["poisson-regression", "negative-binomial"],
  },
  {
    id: "quantile-regression",
    name: "Quantile Regression",
    description: "Models conditional quantiles (e.g., median) rather than the mean.",
    assumptions: ["No distributional assumptions", "Continuous outcome"],
    whenToUse: ["Non-normal outcomes", "Heterogeneous effects", "Median modeling"],
    alternatives: ["Robust regression", "Linear regression"],
    methodFamily: "Regression-based",
    category: "Regression",
    categoryId: "regression",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "advanced",
    alternativeLinks: ["linear-regression", "robust-regression"],
  },
  {
    id: "robust-regression",
    name: "Robust Regression",
    description: "Regression methods resistant to outliers and violations of assumptions.",
    assumptions: ["Linear relationship", "Potential outliers or leverage points"],
    whenToUse: ["Outliers present", "Heavy-tailed errors", "Robust inference"],
    alternatives: ["Quantile regression", "M-estimation"],
    methodFamily: "Regression-based",
    category: "Regression",
    categoryId: "regression",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["linear-regression", "quantile-regression"],
  },
  {
    id: "probit-regression",
    name: "Probit Regression",
    description: "Models binary outcomes using the cumulative normal distribution function.",
    assumptions: ["Binary outcome", "Latent variable interpretation", "Independence"],
    whenToUse: ["Binary classification", "Dose-response", "Latent variable models"],
    alternatives: ["Logistic regression", "Complementary log-log"],
    methodFamily: "Regression-based",
    category: "Regression",
    categoryId: "regression",
    outcomeScale: "binary",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["logistic-regression"],
  },
  
  // === ADDITIONAL ML METHODS ===
  {
    id: "svm",
    name: "Support Vector Machine (SVM)",
    description: "Finds optimal hyperplane to separate classes, can use kernels for non-linear boundaries.",
    assumptions: ["Scaled features recommended", "Sufficient training data"],
    whenToUse: ["Binary classification", "High-dimensional data", "Clear margin of separation"],
    alternatives: ["Logistic regression", "Random forest", "Neural networks"],
    methodFamily: "Machine Learning",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "binary",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["logistic-regression", "random-forest"],
  },
  {
    id: "xgboost",
    name: "XGBoost",
    description: "Optimized gradient boosting library with regularization and parallel processing.",
    assumptions: ["Sufficient training data", "Hyperparameter tuning required"],
    whenToUse: ["Structured/tabular data", "Kaggle competitions", "High accuracy needed"],
    alternatives: ["LightGBM", "CatBoost", "Random forest"],
    methodFamily: "Machine Learning",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["gradient-boosting", "lightgbm", "catboost"],
  },
  {
    id: "lightgbm",
    name: "LightGBM",
    description: "Gradient boosting framework using leaf-wise tree growth for faster training.",
    assumptions: ["Large datasets", "Categorical features supported"],
    whenToUse: ["Large datasets", "Fast training needed", "Memory efficiency"],
    alternatives: ["XGBoost", "CatBoost", "Random forest"],
    methodFamily: "Machine Learning",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["xgboost", "catboost"],
  },
  {
    id: "catboost",
    name: "CatBoost",
    description: "Gradient boosting with native categorical feature support and ordered boosting.",
    assumptions: ["Categorical features present", "Sufficient training data"],
    whenToUse: ["Many categorical features", "Minimal preprocessing", "Prevent overfitting"],
    alternatives: ["XGBoost", "LightGBM", "Random forest"],
    methodFamily: "Machine Learning",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["xgboost", "lightgbm"],
  },
  {
    id: "knn",
    name: "k-Nearest Neighbors (k-NN)",
    description: "Classifies or predicts based on the k closest training examples in feature space.",
    assumptions: ["Meaningful distance metric", "Scaled features", "No noise dominance"],
    whenToUse: ["Simple baseline", "Non-linear patterns", "Instance-based learning"],
    alternatives: ["SVM", "Random forest", "Decision tree"],
    methodFamily: "Machine Learning",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["random-forest", "svm"],
  },
  {
    id: "naive-bayes",
    name: "Naive Bayes",
    description: "Probabilistic classifier based on Bayes' theorem with independence assumption.",
    assumptions: ["Feature independence (often violated)", "Sufficient class representation"],
    whenToUse: ["Text classification", "Fast training needed", "Baseline model"],
    alternatives: ["Logistic regression", "SVM", "Random forest"],
    methodFamily: "Machine Learning",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "binary",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["logistic-regression", "random-forest"],
  },
  {
    id: "decision-tree",
    name: "Decision Tree",
    description: "Tree-structured model making sequential splits based on feature values.",
    assumptions: ["No strict distributional assumptions", "Sufficient training data"],
    whenToUse: ["Interpretable model needed", "Non-linear relationships", "Feature importance"],
    alternatives: ["Random forest", "Gradient boosting", "Rule-based models"],
    methodFamily: "Machine Learning",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["random-forest", "gradient-boosting"],
  },
  {
    id: "elastic-net",
    name: "Elastic Net",
    description: "Regularized regression combining L1 (Lasso) and L2 (Ridge) penalties.",
    assumptions: ["Linear relationships", "High-dimensional data possible"],
    whenToUse: ["Many correlated predictors", "Variable selection + shrinkage", "Combining Lasso and Ridge"],
    alternatives: ["Lasso", "Ridge regression", "Principal components regression"],
    methodFamily: "Regression-based",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "continuous",
    predictorStructure: "multiple continuous",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["lasso-ridge", "multiple-regression"],
  },
  {
    id: "neural-network-mlp",
    name: "Neural Network (MLP)",
    description: "Multi-layer perceptron with hidden layers for learning complex patterns.",
    assumptions: ["Sufficient training data", "Scaled features", "Hyperparameter tuning"],
    whenToUse: ["Complex non-linear patterns", "Large datasets", "Deep learning baseline"],
    alternatives: ["Random forest", "Gradient boosting", "Deep learning architectures"],
    methodFamily: "Machine Learning",
    category: "Prediction",
    categoryId: "ml",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "advanced",
    alternativeLinks: ["random-forest", "gradient-boosting"],
  },
  {
    id: "dbscan",
    name: "DBSCAN",
    description: "Density-based clustering that finds arbitrarily shaped clusters and identifies outliers.",
    assumptions: ["Meaningful distance metric", "Similar density clusters"],
    whenToUse: ["Unknown number of clusters", "Non-spherical clusters", "Outlier detection"],
    alternatives: ["K-means", "HDBSCAN", "OPTICS"],
    methodFamily: "Machine Learning",
    category: "Clustering",
    categoryId: "clustering",
    outcomeScale: "multivariate",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["kmeans", "gaussian-mixture"],
  },
  {
    id: "gaussian-mixture",
    name: "Gaussian Mixture Model",
    description: "Probabilistic model assuming data comes from a mixture of Gaussian distributions.",
    assumptions: ["Gaussian clusters", "Known or estimated number of components"],
    whenToUse: ["Soft clustering", "Probabilistic assignment", "Elliptical clusters"],
    alternatives: ["K-means", "DBSCAN", "Hierarchical clustering"],
    methodFamily: "Machine Learning",
    category: "Clustering",
    categoryId: "clustering",
    outcomeScale: "multivariate",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["kmeans", "dbscan"],
  },
  {
    id: "tsne",
    name: "t-SNE",
    description: "Non-linear dimensionality reduction technique for visualization of high-dimensional data.",
    assumptions: ["Local structure preservation", "Perplexity parameter choice"],
    whenToUse: ["Visualization", "Cluster exploration", "High-dimensional data"],
    alternatives: ["UMAP", "PCA", "MDS"],
    methodFamily: "Machine Learning",
    category: "Dimension Reduction",
    categoryId: "dimension",
    outcomeScale: "multivariate",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["umap", "pca"],
  },
  {
    id: "umap",
    name: "UMAP",
    description: "Uniform Manifold Approximation for fast non-linear dimension reduction preserving global structure.",
    assumptions: ["Manifold assumption", "Sufficient neighbors"],
    whenToUse: ["Fast visualization", "Preserving global structure", "Large datasets"],
    alternatives: ["t-SNE", "PCA", "Isomap"],
    methodFamily: "Machine Learning",
    category: "Dimension Reduction",
    categoryId: "dimension",
    outcomeScale: "multivariate",
    predictorStructure: "none",
    design: "cross-sectional",
    level: "intermediate",
    alternativeLinks: ["tsne", "pca"],
  },
  
  // === TIME SERIES ADDITIONS ===
  {
    id: "prophet",
    name: "Prophet",
    description: "Automated forecasting procedure by Facebook for time series with seasonality and holidays.",
    assumptions: ["Regular time intervals", "Additive/multiplicative seasonality"],
    whenToUse: ["Business forecasting", "Multiple seasonality", "Missing data/outliers"],
    alternatives: ["ARIMA", "Exponential smoothing", "Neural Prophet"],
    methodFamily: "Time-series",
    category: "Time Series",
    categoryId: "time-series",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "time-series",
    level: "intermediate",
    alternativeLinks: ["arima", "exponential-smoothing"],
  },
  {
    id: "adf-test",
    name: "Augmented Dickey-Fuller Test",
    description: "Tests for unit root to determine if a time series is stationary.",
    assumptions: ["Time series data", "AR process"],
    whenToUse: ["Stationarity testing", "Before ARIMA modeling", "Cointegration analysis"],
    alternatives: ["KPSS test", "Phillips-Perron test"],
    methodFamily: "Diagnostic",
    category: "Time Series",
    categoryId: "time-series",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "time-series",
    level: "intermediate",
    alternativeLinks: ["ljung-box"],
  },
  {
    id: "granger-causality",
    name: "Granger Causality Test",
    description: "Tests whether one time series helps predict another (temporal precedence).",
    assumptions: ["Stationary series", "Linear relationships", "No confounders"],
    whenToUse: ["Predictive causality", "Lead-lag relationships", "VAR models"],
    alternatives: ["Cross-correlation", "Transfer entropy"],
    methodFamily: "Time-series",
    category: "Time Series",
    categoryId: "time-series",
    outcomeScale: "continuous",
    predictorStructure: "multiple continuous",
    design: "time-series",
    level: "advanced",
    alternativeLinks: ["var"],
  },
  {
    id: "ljung-box",
    name: "Ljung-Box Test",
    description: "Tests whether any autocorrelations in a series are non-zero.",
    assumptions: ["Time series residuals", "Specified lag order"],
    whenToUse: ["Model diagnostics", "White noise testing", "ARIMA residual check"],
    alternatives: ["Durbin-Watson", "Box-Pierce test"],
    methodFamily: "Diagnostic",
    category: "Time Series",
    categoryId: "time-series",
    outcomeScale: "continuous",
    predictorStructure: "none",
    design: "time-series",
    level: "intermediate",
    alternativeLinks: ["adf-test", "durbin-watson"],
  },
  {
    id: "var",
    name: "Vector Autoregression (VAR)",
    description: "Models multiple time series where each variable depends on its own and others' past values.",
    assumptions: ["Stationary series", "Linear relationships", "Sufficient observations"],
    whenToUse: ["Multiple related time series", "Impulse response", "Forecasting systems"],
    alternatives: ["VECM (cointegrated)", "Structural VAR"],
    methodFamily: "Time-series",
    category: "Time Series",
    categoryId: "time-series",
    outcomeScale: "multivariate",
    predictorStructure: "multiple continuous",
    design: "time-series",
    level: "advanced",
    alternativeLinks: ["arima", "granger-causality"],
  },
  
  // === BAYESIAN METHODS ===
  {
    id: "bayesian-t-test",
    name: "Bayesian t-Test",
    description: "Bayesian alternative to t-test providing posterior probability of hypotheses.",
    assumptions: ["Prior specification", "Normal distribution"],
    whenToUse: ["Quantifying evidence for null", "Prior information available", "Uncertainty quantification"],
    alternatives: ["Frequentist t-test", "Bayesian estimation"],
    methodFamily: "Bayesian",
    category: "Bayesian Methods",
    categoryId: "bayesian",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["t-test-independent", "bayesian-anova"],
  },
  {
    id: "bayesian-regression",
    name: "Bayesian Regression",
    description: "Regression with prior distributions on parameters, yielding posterior distributions.",
    assumptions: ["Prior specification", "Likelihood model"],
    whenToUse: ["Uncertainty quantification", "Prior knowledge incorporation", "Small samples"],
    alternatives: ["Frequentist regression", "Ridge/Lasso"],
    methodFamily: "Bayesian",
    category: "Bayesian Methods",
    categoryId: "bayesian",
    outcomeScale: "continuous",
    predictorStructure: "multiple mixed",
    design: "cross-sectional",
    level: "advanced",
    alternativeLinks: ["linear-regression", "multiple-regression"],
  },
  {
    id: "bayesian-anova",
    name: "Bayesian ANOVA",
    description: "Bayesian approach to comparing group means with Bayes factors.",
    assumptions: ["Prior specification", "Normal distribution"],
    whenToUse: ["Evidence for null hypothesis", "Prior information", "Model comparison"],
    alternatives: ["Frequentist ANOVA", "Bayesian mixed models"],
    methodFamily: "Bayesian",
    category: "Bayesian Methods",
    categoryId: "bayesian",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "intermediate",
    alternativeLinks: ["one-way-anova", "bayesian-t-test"],
  },
  
  // === SURVIVAL ANALYSIS ADDITIONS ===
  {
    id: "accelerated-failure-time",
    name: "Accelerated Failure Time Model",
    description: "Parametric survival model where covariates accelerate or decelerate time to event.",
    assumptions: ["Specified distribution (Weibull, log-normal)", "Multiplicative effect on survival time"],
    whenToUse: ["Parametric survival", "Direct time interpretation", "When proportional hazards fails"],
    alternatives: ["Cox regression", "Parametric survival models"],
    methodFamily: "Survival",
    category: "Survival Analysis",
    categoryId: "survival",
    outcomeScale: "time-to-event",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    level: "advanced",
    alternativeLinks: ["cox-regression"],
  },
  {
    id: "competing-risks",
    name: "Competing Risks Analysis",
    description: "Analyzes time-to-event when multiple event types can occur, only one observed.",
    assumptions: ["Mutually exclusive events", "Independent censoring"],
    whenToUse: ["Multiple failure types", "Cause-specific analysis", "Medical outcomes"],
    alternatives: ["Kaplan-Meier (single event)", "Fine-Gray model"],
    methodFamily: "Survival",
    category: "Survival Analysis",
    categoryId: "survival",
    outcomeScale: "time-to-event",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    level: "advanced",
    alternativeLinks: ["cox-regression", "kaplan-meier"],
  },
  {
    id: "random-survival-forest",
    name: "Random Survival Forest",
    description: "Extension of random forest to survival data with censoring.",
    assumptions: ["Sufficient training data", "Right-censored data"],
    whenToUse: ["Non-linear survival patterns", "Variable importance", "Prediction without proportional hazards"],
    alternatives: ["Cox regression", "Gradient boosted survival"],
    methodFamily: "Machine Learning",
    category: "Survival Analysis",
    categoryId: "survival",
    outcomeScale: "time-to-event",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    level: "advanced",
    alternativeLinks: ["cox-regression", "random-forest"],
  },
  
  // === EFFECT SIZE MEASURES ===
  {
    id: "cohens-d",
    name: "Cohen's d",
    description: "Standardized measure of effect size for difference between two means.",
    assumptions: ["Continuous outcome", "Two groups"],
    whenToUse: ["Reporting effect size", "Power analysis", "Meta-analysis"],
    alternatives: ["Hedges' g (small samples)", "Glass's delta"],
    methodFamily: "Effect Size",
    category: "Effect Size",
    categoryId: "effectsize",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["hedges-g", "eta-squared"],
  },
  {
    id: "hedges-g",
    name: "Hedges' g",
    description: "Bias-corrected version of Cohen's d for small sample sizes.",
    assumptions: ["Continuous outcome", "Two groups", "Small samples"],
    whenToUse: ["Small sample effect size", "Meta-analysis", "Unbiased estimate"],
    alternatives: ["Cohen's d", "Glass's delta"],
    methodFamily: "Effect Size",
    category: "Effect Size",
    categoryId: "effectsize",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["cohens-d"],
  },
  {
    id: "eta-squared",
    name: "Eta-squared / Partial Eta-squared",
    description: "Proportion of variance explained by a factor in ANOVA designs.",
    assumptions: ["ANOVA context", "Continuous outcome"],
    whenToUse: ["ANOVA effect size", "Variance explained", "Reporting results"],
    alternatives: ["Omega-squared", "Cohen's f"],
    methodFamily: "Effect Size",
    category: "Effect Size",
    categoryId: "effectsize",
    outcomeScale: "continuous",
    predictorStructure: "single categorical",
    design: "independent groups",
    level: "basic",
    alternativeLinks: ["cohens-d", "odds-ratio"],
  },
  {
    id: "odds-ratio",
    name: "Odds Ratio",
    description: "Ratio of odds of an event occurring in one group vs another.",
    assumptions: ["Binary outcome", "Two groups or conditions"],
    whenToUse: ["Case-control studies", "Logistic regression", "Risk communication"],
    alternatives: ["Risk ratio", "Hazard ratio"],
    methodFamily: "Effect Size",
    category: "Effect Size",
    categoryId: "effectsize",
    outcomeScale: "binary",
    predictorStructure: "single categorical",
    design: "cross-sectional",
    level: "basic",
    alternativeLinks: ["eta-squared"],
  },
];

const outcomeTypeToScale: Record<string, string[]> = {
  "continuous": ["continuous"],
  "counts": ["count"],
  "ordinal": ["ordinal"],
  "categorical": ["nominal"],
  "binary": ["binary"],
  "time-to-event": ["time-to-event"],
  "multivariate": ["multivariate"],
  "high-dimensional": ["multivariate", "continuous"],
};

const structureToDesign: Record<string, string[]> = {
  "independent": ["independent groups", "cross-sectional"],
  "paired": ["paired/repeated measures"],
  "clustered": ["longitudinal"],
  "longitudinal": ["longitudinal", "paired/repeated measures"],
  "time-series": ["time-series"],
  "spatial": ["cross-sectional"],
};

const assumptionsToMethodFamily: Record<string, string[]> = {
  "parametric": ["Parametric", "Regression-based"],
  "nonparametric": ["Nonparametric"],
  "robust": ["Regression-based", "Resampling"],
  "bayesian": ["Bayesian"],
};

export function getRecommendedTests(selections: Record<string, string>): StatTest[] {
  const { 
    "research-goal": goal, 
    "outcome-type": outcome, 
    "sample-structure": structure, 
    "study-design": studyDesign,
    assumptions 
  } = selections;
  
  let recommended: StatTest[] = [];
  
  const targetOutcomeScales = outcome ? outcomeTypeToScale[outcome] || [] : [];
  const targetDesigns = structure ? structureToDesign[structure] || [] : [];
  const targetMethodFamilies = assumptions ? assumptionsToMethodFamily[assumptions] || [] : [];

  const scoreTest = (test: StatTest): number => {
    let score = 0;
    
    if (targetOutcomeScales.length > 0 && test.outcomeScale && targetOutcomeScales.includes(test.outcomeScale)) {
      score += 3;
    }
    
    if (targetDesigns.length > 0 && test.design && targetDesigns.includes(test.design)) {
      score += 2;
    }
    
    if (targetMethodFamilies.length > 0 && targetMethodFamilies.includes(test.methodFamily)) {
      score += 2;
    }
    
    if (test.level === "basic") score += 1;
    else if (test.level === "intermediate") score += 0.5;
    
    return score;
  };
  
  if (goal === "compare") {
    let candidates = statisticalTests.filter(t => 
      categoryGroups.find(g => g.id === "comparison")?.tests.includes(t.id)
    );
    
    if (targetOutcomeScales.length > 0) {
      candidates = candidates.filter(t => !t.outcomeScale || targetOutcomeScales.includes(t.outcomeScale));
    }
    if (targetDesigns.length > 0) {
      candidates = candidates.filter(t => !t.design || targetDesigns.includes(t.design));
    }
    if (targetMethodFamilies.length > 0) {
      candidates = candidates.filter(t => targetMethodFamilies.includes(t.methodFamily));
    }
    
    recommended = candidates.sort((a, b) => scoreTest(b) - scoreTest(a)).slice(0, 4);
  }
  
  else if (goal === "relationship") {
    let candidates = statisticalTests.filter(t => 
      categoryGroups.find(g => g.id === "correlation")?.tests.includes(t.id)
    );
    
    if (targetMethodFamilies.length > 0) {
      candidates = candidates.filter(t => targetMethodFamilies.includes(t.methodFamily));
    }
    
    recommended = candidates.sort((a, b) => scoreTest(b) - scoreTest(a)).slice(0, 3);
  }
  
  else if (goal === "predict") {
    let candidates = statisticalTests.filter(t => 
      categoryGroups.find(g => g.id === "regression")?.tests.includes(t.id) ||
      categoryGroups.find(g => g.id === "ml")?.tests.includes(t.id)
    );
    
    if (targetOutcomeScales.length > 0) {
      const matched = candidates.filter(t => t.outcomeScale && targetOutcomeScales.includes(t.outcomeScale));
      if (matched.length > 0) candidates = matched;
    }
    
    recommended = candidates.sort((a, b) => scoreTest(b) - scoreTest(a)).slice(0, 4);
  }
  
  else if (goal === "independence") {
    recommended = statisticalTests.filter(t => 
      categoryGroups.find(g => g.id === "categorical")?.tests.includes(t.id) &&
      t.level === "basic"
    ).slice(0, 3);
  }
  
  else if (goal === "time") {
    if (outcome === "time-to-event") {
      recommended = statisticalTests.filter(t => 
        categoryGroups.find(g => g.id === "survival")?.tests.includes(t.id)
      ).sort((a, b) => scoreTest(b) - scoreTest(a)).slice(0, 4);
    } else {
      recommended = statisticalTests.filter(t => 
        categoryGroups.find(g => g.id === "time-series")?.tests.includes(t.id)
      ).sort((a, b) => scoreTest(b) - scoreTest(a)).slice(0, 4);
    }
  }
  
  else if (goal === "unsupervised") {
    let candidates = statisticalTests.filter(t => 
      categoryGroups.find(g => g.id === "clustering")?.tests.includes(t.id) ||
      categoryGroups.find(g => g.id === "dimension")?.tests.includes(t.id)
    );
    recommended = candidates.sort((a, b) => scoreTest(b) - scoreTest(a)).slice(0, 4);
  }
  
  else if (goal === "power") {
    recommended = [statisticalTests.find(t => t.id === "power-analysis")!];
  }
  
  else if (goal === "estimate") {
    let candidates = statisticalTests.filter(t => 
      categoryGroups.find(g => g.id === "comparison")?.tests.includes(t.id) ||
      categoryGroups.find(g => g.id === "effectsize")?.tests.includes(t.id) ||
      categoryGroups.find(g => g.id === "resampling")?.tests.includes(t.id)
    );
    
    if (targetOutcomeScales.length > 0) {
      const matched = candidates.filter(t => !t.outcomeScale || targetOutcomeScales.includes(t.outcomeScale));
      if (matched.length > 0) candidates = matched;
    }
    if (targetDesigns.length > 0) {
      const matched = candidates.filter(t => !t.design || targetDesigns.includes(t.design));
      if (matched.length > 0) candidates = matched;
    }
    if (targetMethodFamilies.length > 0) {
      candidates = candidates.filter(t => targetMethodFamilies.includes(t.methodFamily));
    }
    
    recommended = candidates.sort((a, b) => scoreTest(b) - scoreTest(a)).slice(0, 4);
  }
  
  if (recommended.length === 0) {
    let candidates = statisticalTests.filter(t => t.level === "basic");
    
    if (targetMethodFamilies.length > 0) {
      const matched = candidates.filter(t => targetMethodFamilies.includes(t.methodFamily));
      if (matched.length > 0) candidates = matched;
    }
    if (targetOutcomeScales.length > 0) {
      const matched = candidates.filter(t => !t.outcomeScale || targetOutcomeScales.includes(t.outcomeScale));
      if (matched.length > 0) candidates = matched;
    }
    
    recommended = candidates.sort((a, b) => scoreTest(b) - scoreTest(a)).slice(0, 3);
  }
  
  if (assumptions === "bayesian") {
    const bayesianTests = statisticalTests.filter(t => 
      categoryGroups.find(g => g.id === "bayesian")?.tests.includes(t.id)
    );
    const existingIds = new Set(recommended.map(t => t.id));
    bayesianTests.forEach(t => {
      if (!existingIds.has(t.id)) {
        recommended.push(t);
      }
    });
    recommended = recommended.slice(0, 5);
  }
  
  return recommended.filter(Boolean);
}

export const categoryGroups = [
  { id: "comparison", label: "Group Comparison", tests: ["t-test-independent", "paired-t-test", "one-way-anova", "two-way-anova", "repeated-measures-anova", "mann-whitney", "wilcoxon-signed-rank", "kruskal-wallis", "friedman-test", "welch-t-test", "welch-anova", "ancova", "manova"] },
  { id: "correlation", label: "Correlation", tests: ["pearson-correlation", "spearman-correlation", "partial-correlation", "kendall-tau", "point-biserial", "intraclass-correlation"] },
  { id: "regression", label: "Regression", tests: ["linear-regression", "multiple-regression", "logistic-regression", "poisson-regression", "ordinal-regression", "negative-binomial", "zero-inflated-poisson", "quantile-regression", "robust-regression", "probit-regression"] },
  { id: "categorical", label: "Categorical", tests: ["chi-square", "fisher-exact", "mcnemar-test", "cochran-q", "cramers-v", "cohens-kappa", "fleiss-kappa"] },
  { id: "mixed", label: "Mixed Models", tests: ["linear-mixed-model", "glmm"] },
  { id: "time-series", label: "Time Series", tests: ["arima", "exponential-smoothing", "prophet", "adf-test", "granger-causality", "ljung-box", "var"] },
  { id: "survival", label: "Survival Analysis", tests: ["kaplan-meier", "log-rank-test", "cox-regression", "accelerated-failure-time", "competing-risks", "random-survival-forest"] },
  { id: "clustering", label: "Clustering", tests: ["kmeans", "hierarchical-clustering", "dbscan", "gaussian-mixture"] },
  { id: "dimension", label: "Dimension Reduction", tests: ["pca", "factor-analysis", "tsne", "umap"] },
  { id: "ml", label: "Machine Learning", tests: ["random-forest", "gradient-boosting", "lasso-ridge", "svm", "xgboost", "lightgbm", "catboost", "knn", "naive-bayes", "decision-tree", "elastic-net", "neural-network-mlp"] },
  { id: "resampling", label: "Resampling", tests: ["bootstrap", "permutation-test"] },
  { id: "assumption", label: "Assumption Testing", tests: ["levene-test", "bartlett-test", "brown-forsythe", "fligner-killeen", "hartley-fmax", "shapiro-wilk", "kolmogorov-smirnov", "anderson-darling", "dagostino-pearson", "durbin-watson", "breusch-pagan", "vif"] },
  { id: "posthoc", label: "Post-hoc Tests", tests: ["tukey-hsd", "bonferroni", "holm-bonferroni", "benjamini-hochberg", "dunnett-test", "games-howell", "scheffe-test", "dunn-test"] },
  { id: "bayesian", label: "Bayesian Methods", tests: ["bayesian-t-test", "bayesian-regression", "bayesian-anova"] },
  { id: "effectsize", label: "Effect Size", tests: ["cohens-d", "hedges-g", "eta-squared", "odds-ratio"] },
  { id: "planning", label: "Study Planning", tests: ["power-analysis"] },
];
