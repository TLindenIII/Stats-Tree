export interface StatTest {
  id: string;
  wikipediaUrl?: string | null;
  name: string;
  description: string;
  assumptions: string[];
  whenToUse: string[];

  category: string;

  outcome?: string | null;
  predictorStructure?: string | null;
  design?: string | null;
  alternativeLinks?: string[];
  pythonCode?: string;
  rCode?: string;
  // rules property removed
}

// ── Recommendation output ──────────────────────────────────────────────

export interface Recommendation {
  primary: StatTest[];
  alternatives: StatTest[];
  companions: StatTest[];
}

export const statisticalTests: StatTest[] = [
  // One Sample
  {
    id: "one-sample-t-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test",
    name: "One-Sample t-Test",
    description:
      "Tests whether the mean of a single sample differs from a specified reference (hypothesized) mean.",
    assumptions: [
      "Independent observations",
      "Numeric outcome",
      "Population (or sample) approximately normal, or n large with no extreme outliers",
    ],
    whenToUse: [
      "Compare a sample mean to a known/hypothesized value ($\mu_0$)",
      "You have one group and a continuous outcome",
      "You want a t-based CI and p-value for the mean difference from $\mu_0$",
    ],
    category: "One Sample",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["wilcoxon-signed-rank", "permutation-test", "bootstrap", "bayesian-t-test"],
    pythonCode: `
# x is a 1D array-like of observations
# mu0 is the hypothesized population mean
mu0 = 0.0
t_stat, p_val = scipy.stats.ttest_1samp(x, popmean=mu0)

# Optional: (1 - alpha) confidence interval for mean difference (mean(x) - mu0)
alpha = 0.05
x = np.asarray(x, dtype=float)
n = x.size
df = n - 1
diff_mean = x.mean() - mu0
se = x.std(ddof=1) / np.sqrt(n)
tcrit = scipy.stats.t.ppf(1 - alpha / 2, df)
ci = (diff_mean - tcrit * se, diff_mean + tcrit * se)
  `.trim(),
    rCode: `
# x is a numeric vector of observations
# mu0 is the hypothesized population mean
mu0 <- 0
t_out <- t.test(x, mu = mu0)
# Optional: extract t statistic, p-value, and confidence interval
t_stat <- unname(t_out$statistic)
p_val  <- t_out$p.value
ci     <- t_out$conf.int
  `.trim(),
  },
  {
    id: "one-proportion-z-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/One-proportion_z-test",
    name: "One-Proportion z-Test",
    description:
      "Normal-approximation test for whether a sample proportion differs from a hypothesized value.",
    assumptions: [
      "Binary outcome",
      "Independent trials",
      "Large-sample normal approximation is reasonable (e.g., n*p0 and n*(1-p0) sufficiently large)",
    ],
    whenToUse: [
      "One-sample proportion test against p0 with moderate/large n",
      "Quick approximation when exact binomial is not required",
    ],
    category: "One Sample",
    outcome: "binary",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["binomial-test", "bootstrap", "permutation-test"],
    pythonCode: ``,
    rCode: ``,
  },
  {
    id: "binomial-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Binomial_test",
    name: "Exact Binomial Test",
    description:
      "Exact test for whether the probability of success in Bernoulli trials differs from a hypothesized value; also provides exact confidence intervals.",
    assumptions: [
      "Binary outcome (success/failure)",
      "Independent trials",
      "Constant probability of success across trials",
    ],
    whenToUse: [
      "One-sample proportion test against a hypothesized p0",
      "Small samples or when normal approximation is questionable",
      "Exact CI for a proportion",
    ],
    category: "One Sample",
    outcome: "binary",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["one-proportion-z-test", "bootstrap", "permutation-test"],
    pythonCode: ``,
    rCode: ``,
  },

  // Group Comparison - Parametric
  {
    id: "t-test-independent",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Student%27s_t-test",
    name: "Independent Samples (Pooled) t-Test",
    description:
      "Compares means of two independent groups to determine if they are statistically different.",
    assumptions: [
      "Independent observations within and between groups",
      "Numeric outcome",
      "Difference of means ~ normal (or n large; no extreme outliers)",
      "Variances similar",
    ],
    whenToUse: [
      "Compare means of two independent groups",
      "Data roughly symmetric or n moderately large",
      "Variances similar",
    ],
    category: "Group Comparison",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: [
      "welch-t-test",
      "mann-whitney",
      "permutation-test",
      "bootstrap",
      "bayesian-t-test",
    ],
    pythonCode: `
# a and b are 1D arrays of observations
t_pooled, p_val = scipy.stats.ttest_ind(a, b, equal_var=True)
`.trim(),
    rCode: `
# a and b are numeric vectors of observations
t_pooled <- t.test(a, b, var.equal = TRUE)
`.trim(),
  },
  {
    id: "paired-t-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Student%27s_t-test",
    name: "Paired Samples t-Test",
    description:
      "Compares means from the same group at two different times or under two different conditions.",
    assumptions: [
      "Paired/matched observations",
      "Pairs independent of other pairs",
      "Numeric outcome",
      "Differences $d_i = x_{1,i} - x_{2,i}$ ~ normal (or n large; no extreme outliers in $d_i$)",
    ],
    whenToUse: [
      "Before-after / within-subject comparisons",
      "Matched pairs / crossover designs",
      "Analyze the mean of within-pair differences",
    ],
    category: "Group Comparison",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "paired",
    alternativeLinks: ["wilcoxon-signed-rank", "permutation-test", "bootstrap", "bayesian-t-test"],
    pythonCode: `
# a and b are paired 1D arrays: each position i is the same subject/unit measured twice
# (e.g., pre vs post, or condition A vs condition B), so length(a) == length(b).
t_paired, p_val = scipy.stats.ttest_rel(a, b)
`.trim(),
    rCode: `
# a and b are paired numeric vectors: each position i is the same subject/unit measured twice
# (e.g., pre vs post, or condition A vs condition B), so length(a) == length(b).
t_paired <- t.test(a, b, paired = TRUE)
    `.trim(),
  },
  {
    id: "one-way-anova",
    wikipediaUrl: "https://en.wikipedia.org/wiki/One-way_analysis_of_variance",
    name: "One-Way ANOVA",
    description:
      "Tests whether there are statistically significant differences between the means of three or more independent groups.",
    assumptions: [
      "Normal distribution in each group",
      "Equal variances (homoscedasticity)",
      "Independent observations",
    ],
    whenToUse: ["Comparing 3+ group means", "One categorical predictor", "Continuous outcome"],
    category: "Group Comparison",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["welch-anova", "kruskal-wallis", "permutation-test", "bootstrap", "bayesian-anova"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "two-way-anova",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Two-way_analysis_of_variance",
    name: "Two-Way ANOVA",
    description:
      "Tests the effect of two independent categorical variables on a continuous outcome, including their interaction.",
    assumptions: [
      "Normal distribution",
      "Equal variances",
      "Independent observations",
      "No significant outliers",
    ],
    whenToUse: [
      "Two categorical predictors",
      "Factorial experimental design",
      "Testing interaction effects",
    ],
    category: "Group Comparison",
    outcome: "continuous",
    predictorStructure: "multiple categorical",
    design: "factorial",
    alternativeLinks: ["linear-mixed-model", "ancova", "manova", "bayesian-anova"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "repeated-measures-anova",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Repeated_measures_design",
    name: "Repeated Measures ANOVA",
    description:
      "Tests differences across multiple time points or conditions for the same subjects.",
    assumptions: ["Sphericity", "Normal distribution", "No significant outliers"],
    whenToUse: [
      "Multiple measurements on same subjects",
      "Longitudinal within-subject design",
      "Before-during-after comparisons",
    ],
    category: "Group Comparison",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "repeated",
    alternativeLinks: ["linear-mixed-model", "friedman-test", "permutation-test", "bootstrap"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "two-proportion-z-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Two-proportion_z-test",
    name: "Two-Proportion z-Test",
    description:
      "Tests whether two independent proportions differ using a normal approximation (pooled under the null).",
    assumptions: [
      "Binary outcome",
      "Independent samples",
      "Large-sample normal approximation is reasonable in both groups",
    ],
    whenToUse: [
      "Compare two independent proportions (A vs B)",
      "Moderate/large sample sizes with expected successes/failures sufficiently large",
    ],
    category: "Categorical",
    outcome: "binary",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["chi-square-2x2", "fisher-exact", "bootstrap", "permutation-test"],
    pythonCode: ``,
    rCode: ``,
  },
  // Group Comparison - Non-parametric
  {
    id: "mann-whitney",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test",
    name: "Mann-Whitney U Test",
    description: "Non-parametric test that compares distributions of two independent groups.",
    assumptions: [
      "Independent samples",
      "Ordinal or continuous outcome",
      "Similar distribution shapes",
    ],
    whenToUse: ["Non-normal distributions", "Ordinal data", "Small sample sizes"],
    category: "Group Comparison",
    outcome: "ordinal",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["welch-t-test", "t-test-independent", "permutation-test", "bootstrap"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "wilcoxon-signed-rank",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test",
    name: "Wilcoxon Signed-Rank Test",
    description: "Non-parametric test for comparing two related samples or repeated measurements.",
    assumptions: [
      "Paired observations",
      "Ordinal or continuous outcome",
      "Symmetric distribution of differences",
    ],
    whenToUse: [
      "Paired data with non-normal differences",
      "Ordinal outcomes",
      "Before-after comparisons",
    ],
    category: "Group Comparison",
    outcome: "ordinal",
    predictorStructure: "single categorical",
    design: "paired",
    alternativeLinks: ["paired-t-test", "permutation-test", "bootstrap"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "kruskal-wallis",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_test",
    name: "Kruskal-Wallis H Test",
    description:
      "Non-parametric alternative to one-way ANOVA for comparing three or more independent groups.",
    assumptions: [
      "Independent samples",
      "Ordinal or continuous outcome",
      "Similar distribution shapes",
    ],
    whenToUse: [
      "Comparing 3+ groups with non-normal data",
      "Ordinal outcomes",
      "Unequal group sizes",
    ],
    category: "Group Comparison",
    outcome: "ordinal",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["one-way-anova", "welch-anova", "permutation-test", "bootstrap", "dunn-test"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "friedman-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Friedman_test",
    name: "Friedman Test",
    description:
      "Non-parametric alternative to repeated measures ANOVA for ordinal or non-normal data.",
    assumptions: [
      "Related samples",
      "Ordinal or continuous outcome",
      "Same subjects across conditions",
    ],
    whenToUse: ["Repeated measures with non-normal data", "Ordinal outcomes", "Blocked designs"],
    category: "Group Comparison",
    outcome: "ordinal",
    predictorStructure: "single categorical",
    design: "repeated",
    alternativeLinks: ["repeated-measures-anova", "linear-mixed-model", "permutation-test", "bootstrap"],
    pythonCode: "",
    rCode: "",
  },

  // Relationship/Correlation
  {
    id: "pearson-correlation",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Pearson_correlation_coefficient",
    name: "Pearson Correlation",
    description: "Measures the linear relationship between two continuous variables.",
    assumptions: [
      "Linear relationship",
      "Bivariate normality",
      "No outliers",
      "Continuous variables",
    ],
    whenToUse: [
      "Measuring linear association",
      "Both variables continuous",
      "Normally distributed data",
    ],
    category: "Correlation",
    outcome: "continuous",
    predictorStructure: "single continuous",
    design: "independent",
    alternativeLinks: ["spearman-correlation", "kendall-tau", "partial-correlation"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "spearman-correlation",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient",
    name: "Spearman Rank Correlation",
    description: "Non-parametric measure of monotonic relationship between two variables.",
    assumptions: [
      "Monotonic relationship",
      "Ordinal or continuous data",
      "Independent observations",
    ],
    whenToUse: ["Non-linear monotonic relationships", "Ordinal data", "Outliers present"],
    category: "Correlation",
    outcome: "ordinal",
    predictorStructure: "single continuous",
    design: "independent",
    alternativeLinks: ["kendall-tau", "pearson-correlation", "partial-correlation"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "partial-correlation",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Partial_correlation",
    name: "Partial Correlation",
    description:
      "Measures association between two variables while controlling for one or more other variables.",
    assumptions: ["Linear relationships", "No multicollinearity", "Continuous variables"],
    whenToUse: ["Controlling for confounders", "Isolating relationships", "Multiple predictors"],
    category: "Correlation",
    outcome: "continuous",
    predictorStructure: "multiple continuous",
    design: "independent",
    alternativeLinks: ["multiple-regression", "pearson-correlation", "spearman-correlation"],
    pythonCode: "",
    rCode: "",
  },
  // Regression
  {
    id: "linear-regression",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Linear_regression",
    name: "Linear Regression",
    description: "Models the relationship between a continuous outcome and one or more predictors.",
    assumptions: [
      "Linear relationship",
      "Normal residuals",
      "Homoscedasticity",
      "Independence of errors",
    ],
    whenToUse: [
      "Predicting continuous outcomes",
      "Multiple predictors",
      "Quantifying relationships",
    ],
    category: "Regression",
    outcome: "continuous",
    predictorStructure: "single continuous",
    design: "independent",
    alternativeLinks: ["multiple-regression", "robust-regression", "quantile-regression", "bayesian-regression"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "multiple-regression",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Linear_regression",
    name: "Multiple Linear Regression",
    description:
      "Models relationship between continuous outcome and multiple predictors simultaneously.",
    assumptions: [
      "Linear relationships",
      "Normal residuals",
      "No multicollinearity",
      "Homoscedasticity",
    ],
    whenToUse: ["Multiple predictors", "Controlling for confounders", "Prediction with covariates"],
    category: "Regression",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["linear-regression", "robust-regression", "quantile-regression", "bayesian-regression", "lasso-ridge", "elastic-net"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "logistic-regression",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Logistic_regression",
    name: "Logistic Regression",
    description: "Models the probability of a binary outcome based on one or more predictors.",
    assumptions: [
      "Binary outcome",
      "Independence of observations",
      "No multicollinearity",
      "Linear relationship with log-odds",
    ],
    whenToUse: ["Binary classification", "Odds ratio estimation", "Multiple predictors"],
    category: "Regression",
    outcome: "binary",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["probit-regression", "naive-bayes", "svm", "random-forest", "gradient-boosting"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "poisson-regression",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Poisson_regression",
    name: "Poisson Regression",
    description:
      "Models count data as a function of predictors, assuming counts follow a Poisson distribution.",
    assumptions: [
      "Count outcome",
      "Mean equals variance",
      "Independence",
      "Log-linear relationship",
    ],
    whenToUse: ["Count outcomes", "Rate data", "Event frequencies"],
    category: "Regression",
    outcome: "count",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["negative-binomial", "zero-inflated-poisson", "glmm", "gee"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "ordinal-regression",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Ordinal_regression",
    name: "Ordinal Logistic Regression",
    description: "Models ordinal outcomes with three or more ordered categories.",
    assumptions: ["Ordinal outcome", "Proportional odds", "Independence"],
    whenToUse: ["Ordinal outcomes (Likert scales)", "Ranked categories", "Multiple predictors"],
    category: "Regression",
    outcome: "ordinal",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["logistic-regression", "random-forest", "gradient-boosting"],
    pythonCode: "",
    rCode: "",
  },
  // Categorical Analysis
  {
    id: "chi-square",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Chi-squared_test",
    name: "Chi-Square Test of Independence",
    description:
      "Tests whether there is a significant association between two categorical variables.",
    assumptions: [
      "Expected cell count >= 5 in 80% of cells",
      "Independent observations",
      "Categorical variables",
    ],
    whenToUse: [
      "Testing association between categorical variables",
      "Contingency tables",
      "Independence testing",
    ],
    category: "Categorical",
    outcome: "categorical",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["fisher-freeman-halton", "fisher-exact"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "chi-square-2x2",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Chi-squared_test",
    name: "Chi-Square Test (2x2)",
    description: "Tests association between two binary variables (large sample).",
    assumptions: ["Expected cell count >= 5", "Independent observations", "2x2 table"],
    whenToUse: ["Testing association in 2x2 tables", "Sample size sufficient"],
    category: "Categorical",
    outcome: "categorical",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["fisher-exact", "two-proportion-z-test", "phi-coefficient", "odds-ratio"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "fisher-freeman-halton",
    wikipediaUrl:
      "https://en.wikipedia.org/wiki/Fisher%27s_exact_test#Freeman%E2%80%93Halton_extension",
    name: "Fisher-Freeman-Halton Exact Test (rxc)",
    description:
      "Exact test of independence for rxc contingency tables (extension of Fisher's exact test).",
    assumptions: [
      "rxc contingency table",
      "Fixed marginals (conditional framework)",
      "Independence",
    ],
    whenToUse: [
      "Small sample categorical association in rxc tables",
      "Expected counts too small for chi-square approximation",
      "Exact p-value preferred over asymptotic chi-square",
    ],
    category: "Categorical",
    outcome: "categorical",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["chi-square", "permutation-test"],
    pythonCode: ``,
    rCode: ``,
  },
  {
    id: "fisher-exact",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Fisher%27s_exact_test",
    name: "Fisher's Exact Test",
    description:
      "Exact test for association in 2x2 contingency tables, especially with small samples.",
    assumptions: ["2x2 table", "Fixed marginals", "Independent observations"],
    whenToUse: ["Small sample sizes", "Expected counts < 5", "2x2 tables"],
    category: "Categorical",
    outcome: "categorical",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["chi-square-2x2", "two-proportion-z-test", "bootstrap", "permutation-test"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "mcnemar-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/McNemar%27s_test",
    name: "McNemar's Test",
    description: "Tests for differences in paired proportions or matched case-control studies.",
    assumptions: ["Paired binary data", "Matched samples", "Sufficient discordant pairs"],
    whenToUse: ["Before-after binary outcomes", "Matched pairs", "Diagnostic test comparison"],
    category: "Categorical",
    outcome: "binary",
    predictorStructure: "single categorical",
    design: "paired",
    alternativeLinks: ["cochran-q", "permutation-test"],
    pythonCode: "",
    rCode: "",
  },
  // Mixed/Multilevel Models
  {
    id: "linear-mixed-model",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Linear_mixed-effects_model",
    name: "Linear Mixed Model",
    description:
      "Models continuous outcomes with both fixed and random effects for hierarchical/clustered data.",
    assumptions: [
      "Normal residuals",
      "Linear relationships",
      "Random effects normally distributed",
    ],
    whenToUse: ["Clustered/nested data", "Repeated measures", "Unbalanced designs"],
    category: "Mixed Models",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    alternativeLinks: ["repeated-measures-anova", "glmm", "gee", "bayesian-regression"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "glmm",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Generalized_linear_mixed_model",
    name: "Generalized Linear Mixed Model",
    description: "Extends GLM to include random effects for non-normal outcomes with clustering.",
    assumptions: [
      "Appropriate link function",
      "Random effects specification",
      "Conditional independence",
    ],
    whenToUse: [
      "Non-normal outcomes with clustering",
      "Binary/count data in hierarchical structures",
    ],
    category: "Mixed Models",
    outcome: "binary",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    alternativeLinks: ["gee", "logistic-regression", "poisson-regression"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "gee",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Generalized_estimating_equation",
    name: "Generalized Estimating Equations (GEE)",
    description:
      "Marginal (population-averaged) regression for correlated/clustered data, specifying a working correlation structure.",
    assumptions: [
      "Clustered or repeated observations",
      "Correct mean model specification",
      "Working correlation structure chosen (robust sandwich SEs mitigate misspecification)",
    ],
    whenToUse: [
      "Repeated measures / clustered outcomes when interest is population-averaged effects",
      "Binary/count/continuous outcomes with correlated responses",
      "Alternative to GLMM when random effects are not the focus",
    ],
    category: "Mixed Models",
    outcome: "binary",
    predictorStructure: "multiple mixed",
    design: "clustered",
    alternativeLinks: ["glmm", "linear-mixed-model", "logistic-regression", "poisson-regression"],
    pythonCode: ``,
    rCode: ``,
  },
  // Time Series
  {
    id: "arima",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average",
    name: "ARIMA Model",
    description: "Autoregressive integrated moving average model for time series forecasting.",
    assumptions: [
      "Stationarity (after differencing)",
      "No seasonality (or use SARIMA)",
      "Constant variance",
    ],
    whenToUse: ["Time series forecasting", "Trend modeling", "Autocorrelated data"],
    category: "Time Series",
    outcome: "continuous",
    predictorStructure: "none",
    design: "time-series",
    alternativeLinks: ["exponential-smoothing", "prophet", "var"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "exponential-smoothing",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Exponential_smoothing",
    name: "Exponential Smoothing",
    description:
      "Weighted moving average methods for time series forecasting with trend and seasonality.",
    assumptions: ["Regular time intervals", "Stationary error variance"],
    whenToUse: ["Short-term forecasting", "Trend and seasonality", "Simpler interpretation"],
    category: "Time Series",
    outcome: "continuous",
    predictorStructure: "none",
    design: "time-series",
    alternativeLinks: ["arima", "prophet"],
    pythonCode: "",
    rCode: "",
  },
  // Survival Analysis
  {
    id: "kaplan-meier",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Kaplan%E2%80%93Meier_estimator",
    name: "Kaplan-Meier Estimator",
    description: "Non-parametric estimator of survival function from time-to-event data.",
    assumptions: [
      "Independent censoring",
      "Well-defined time origin",
      "No competing risks (or adjust)",
    ],
    whenToUse: [
      "Estimating survival curves",
      "Handling censored data",
      "Descriptive survival analysis",
    ],
    category: "Survival Analysis",
    outcome: "time_to_event",
    predictorStructure: "none",
    design: "longitudinal",
    alternativeLinks: ["cox-regression", "accelerated-failure-time"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "log-rank-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Logrank_test",
    name: "Log-Rank Test",
    description: "Compares survival distributions between two or more groups.",
    assumptions: ["Proportional hazards", "Independent censoring", "Non-informative censoring"],
    whenToUse: [
      "Comparing survival curves",
      "Clinical trial endpoints",
      "Time-to-event comparisons",
    ],
    category: "Survival Analysis",
    outcome: "time_to_event",
    predictorStructure: "single categorical",
    design: "longitudinal",
    alternativeLinks: ["cox-regression", "accelerated-failure-time"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "cox-regression",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Proportional_hazards_model",
    name: "Cox Proportional Hazards",
    description: "Semi-parametric regression model for time-to-event data with covariates.",
    assumptions: [
      "Proportional hazards",
      "Independent censoring",
      "Linear covariate effects on log-hazard",
    ],
    whenToUse: ["Survival with covariates", "Hazard ratio estimation", "Adjusting for confounders"],
    category: "Survival Analysis",
    outcome: "time_to_event",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    alternativeLinks: ["accelerated-failure-time", "random-survival-forest", "competing-risks", "kaplan-meier"],
    pythonCode: "",
    rCode: "",
  },
  // Unsupervised Learning
  {
    id: "kmeans",
    wikipediaUrl: "https://en.wikipedia.org/wiki/K-means_clustering",
    name: "K-Means Clustering",
    description: "Partitions observations into k clusters by minimizing within-cluster variance.",
    assumptions: ["Spherical clusters", "Similar cluster sizes", "Numeric features"],
    whenToUse: ["Finding natural groupings", "Customer segmentation", "Pattern discovery"],
    category: "Clustering",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["gaussian-mixture", "hierarchical-clustering", "dbscan"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "hierarchical-clustering",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Hierarchical_clustering",
    name: "Hierarchical Clustering",
    description: "Builds a tree of clusters using agglomerative or divisive approaches.",
    assumptions: ["Meaningful distance metric", "Appropriate linkage method"],
    whenToUse: [
      "Exploring cluster hierarchy",
      "Dendrogram visualization",
      "Unknown number of clusters",
    ],
    category: "Clustering",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["kmeans", "dbscan", "gaussian-mixture"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "pca",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Principal_component_analysis",
    name: "Principal Component Analysis",
    description: "Reduces dimensionality by finding orthogonal directions of maximum variance.",
    assumptions: ["Linear relationships", "Continuous variables", "Standardized features"],
    whenToUse: [
      "Dimension reduction",
      "Feature extraction",
      "Visualization of high-dimensional data",
    ],
    category: "Dimension Reduction",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["factor-analysis", "umap", "tsne"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "factor-analysis",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Factor_analysis",
    name: "Factor Analysis",
    description: "Identifies latent factors underlying observed variables.",
    assumptions: ["Linear relationships", "Multivariate normality", "Sufficient sample size"],
    whenToUse: [
      "Scale development",
      "Latent construct identification",
      "Data reduction with theory",
    ],
    category: "Dimension Reduction",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["pca"],
    pythonCode: "",
    rCode: "",
  },
  // Machine Learning
  {
    id: "random-forest",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Random_forest",
    name: "Random Forest",
    description:
      "Ensemble of decision trees for classification or regression with improved accuracy.",
    assumptions: ["No strict distributional assumptions", "Sufficient training data"],
    whenToUse: ["Complex non-linear relationships", "Feature importance", "Robust predictions"],
    category: "Machine Learning",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["gradient-boosting", "xgboost", "lightgbm", "catboost", "svm", "knn", "decision-tree", "neural-network-mlp"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "gradient-boosting",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Gradient_boosting",
    name: "Gradient Boosting",
    description: "Sequentially builds weak learners to minimize prediction errors.",
    assumptions: ["Sufficient training data", "Proper hyperparameter tuning"],
    whenToUse: ["High prediction accuracy", "Structured/tabular data", "Competitions"],
    category: "Machine Learning",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["xgboost", "lightgbm", "catboost", "random-forest", "decision-tree"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "lasso-ridge",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Regularization_(mathematics)#Regression",
    name: "Lasso/Ridge Regression",
    description: "Regularized regression methods that shrink coefficients to prevent overfitting.",
    assumptions: ["Linear relationships", "Standardized predictors recommended"],
    whenToUse: ["High-dimensional data", "Multicollinearity", "Variable selection (Lasso)"],
    category: "Machine Learning",
    outcome: "continuous",
    predictorStructure: "multiple continuous",
    design: "independent",
    alternativeLinks: ["elastic-net", "multiple-regression", "bayesian-regression"],
    pythonCode: "",
    rCode: "",
  },
  // RESAMPLING
  {
    id: "bootstrap",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Bootstrapping_(statistics)",
    name: "Bootstrap",
    description: "Resampling method to estimate sampling distributions and confidence intervals.",
    assumptions: ["Representative sample", "Independent observations"],
    whenToUse: ["Unknown sampling distribution", "Complex statistics", "Small samples"],
    category: "Resampling",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["permutation-test", "jackknife", "cross-validation"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "permutation-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Permutation_test",
    name: "Permutation Test",
    description: "Non-parametric test using random permutations to generate null distribution.",
    assumptions: ["Exchangeability under null", "Independent observations"],
    whenToUse: ["No distributional assumptions", "Small samples", "Complex test statistics"],
    category: "Resampling",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["bootstrap", "mann-whitney", "wilcoxon-signed-rank"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "cross-validation",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Cross-validation_(statistics)",
    name: "Cross-Validation",
    description:
      "Resampling procedure used to estimate out-of-sample model performance by repeatedly splitting data into training and validation sets.",
    assumptions: [
      "Validation strategy matches the data-generating structure (IID for standard CV; grouped/time-aware CV when needed).",
      "No data leakage: preprocessing and feature selection are fit within each training fold only.",
    ],
    whenToUse: [
      "Estimate generalization performance",
      "Compare models or hyperparameters",
      "Prevent overfitting during model selection",
    ],
    category: "Resampling",
    outcome: "any",
    predictorStructure: "any",
    design: "resampling",
    alternativeLinks: ["bootstrap", "jackknife"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "jackknife",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Jackknife_resampling",
    name: "Jackknife",
    description:
      "Leave-one-out resampling method used to estimate bias and standard error of a statistic by recomputing it after omitting each observation in turn.",
    assumptions: [
      "Most reliable for smooth statistics (e.g., means, regression coefficients).",
      "Can be unstable for non-smooth statistics (e.g., medians/quantiles) or very small samples.",
    ],
    whenToUse: [
      "Estimate standard error of a statistic",
      "Estimate bias of an estimator",
      "Quick influence-style sensitivity checks",
    ],
    category: "Resampling",
    outcome: "any",
    predictorStructure: "none",
    design: "resampling",
    alternativeLinks: ["bootstrap", "cross-validation"],
    pythonCode: "",
    rCode: "",
  },

  // Power Analysis
  {
    id: "power-analysis",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Statistical_power",
    name: "Power Analysis",
    description: "Calculates required sample size or statistical power for detecting an effect.",
    assumptions: ["Specified effect size", "Known alpha level", "Appropriate test selection"],
    whenToUse: ["Study planning", "Grant applications", "Sample size justification"],
    category: "Study Planning",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["cohens-d", "odds-ratio", "risk-ratio"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "bartlett-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Bartlett%27s_test",
    name: "Bartlett's Test",
    description:
      "Tests equality of variances across groups, sensitive to departures from normality.",
    assumptions: ["Normal distribution in each group", "Independent samples"],
    whenToUse: ["Variance homogeneity testing", "Normally distributed data", "Before ANOVA"],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["levene-test", "brown-forsythe", "fligner-killeen"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "brown-forsythe",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Brown%E2%80%93Forsythe_test",
    name: "Brown-Forsythe Test",
    description: "Robust test for equality of variances using deviations from group medians.",
    assumptions: ["Independent samples", "Continuous data"],
    whenToUse: ["Variance testing with skewed data", "Outlier-resistant variance comparison"],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["levene-test", "fligner-killeen", "bartlett-test"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "fligner-killeen",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Fligner%E2%80%93Killeen_test",
    name: "Fligner-Killeen Test",
    description:
      "Non-parametric test for homogeneity of variances, highly robust to non-normality.",
    assumptions: ["Independent samples", "Ordinal or continuous data"],
    whenToUse: ["Severe non-normality", "Robust variance testing", "Small samples"],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["levene-test", "brown-forsythe"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "hartley-fmax",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Hartley%27s_test",
    name: "Hartley's F-max Test",
    description:
      "Quick test for variance homogeneity using ratio of largest to smallest group variance.",
    assumptions: ["Equal sample sizes", "Normal distribution", "Independent samples"],
    whenToUse: ["Quick variance ratio check", "Balanced designs", "Preliminary analysis"],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["bartlett-test", "levene-test", "brown-forsythe"],
    pythonCode: "",
    rCode: "",
  },
  // Normality Tests
  {
    id: "shapiro-wilk",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Shapiro%E2%80%93Wilk_test",
    name: "Shapiro-Wilk Test",
    description:
      "Tests whether a sample comes from a normally distributed population. Considered one of the most powerful normality tests.",
    assumptions: ["Sample size typically between 3-5000", "Independent observations"],
    whenToUse: [
      "Checking normality assumption",
      "Small to moderate samples",
      "Before parametric tests",
    ],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["anderson-darling", "dagostino-pearson", "kolmogorov-smirnov"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "kolmogorov-smirnov",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test",
    name: "Kolmogorov-Smirnov Test",
    description:
      "Compares sample distribution to a reference distribution (often normal) or compares two samples.",
    assumptions: ["Continuous distribution", "Independent observations"],
    whenToUse: [
      "Testing any distributional assumption",
      "Comparing two distributions",
      "Large samples",
    ],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["anderson-darling", "shapiro-wilk"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "anderson-darling",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test",
    name: "Anderson-Darling Test",
    description:
      "Tests whether a sample comes from a specified distribution, with more weight on tails than KS test.",
    assumptions: ["Continuous distribution", "Known reference distribution"],
    whenToUse: [
      "Normality testing with tail sensitivity",
      "Distribution fitting",
      "Quality control",
    ],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["shapiro-wilk", "kolmogorov-smirnov", "dagostino-pearson"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "dagostino-pearson",
    wikipediaUrl: "https://en.wikipedia.org/wiki/D%27Agostino%27s_K-squared_test",
    name: "D'Agostino-Pearson Test",
    description: "Omnibus test combining skewness and kurtosis to test for normality.",
    assumptions: ["Sample size > 20", "Independent observations"],
    whenToUse: ["Moderate to large samples", "Detecting non-normality from skewness/kurtosis"],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["shapiro-wilk", "anderson-darling"],
    pythonCode: "",
    rCode: "",
  },
  // Variance Tests
  {
    id: "levene-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Levene%27s_test",
    name: "Levene's Test",
    description:
      "Tests equality of variances across groups; more robust than Bartlett’s when normality is violated.",
    assumptions: [
      "Independent samples",
      "Continuous (or at least ordinal) outcome",
      "Grouping variable defines 2+ groups",
    ],
    whenToUse: [
      "Checking homogeneity of variance before ANOVA/t-tests",
      "When normality is questionable (preferred over Bartlett’s)",
      "Comparing spread across multiple groups",
    ],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["brown-forsythe", "fligner-killeen", "bartlett-test", "hartley-fmax"],
    pythonCode: "",
    rCode: "",
  },
  // Regression Diagnostics
  {
    id: "durbin-watson",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Durbin%E2%80%93Watson_statistic",
    name: "Durbin-Watson Test",
    description: "Tests for autocorrelation in residuals from regression analysis.",
    assumptions: ["Linear regression model", "First-order autocorrelation"],
    whenToUse: ["Time series regression", "Detecting serial correlation", "Model diagnostics"],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "none",
    design: "time-series",
    alternativeLinks: ["ljung-box", "granger-causality"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "breusch-pagan",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Breusch%E2%80%93Pagan_test",
    name: "Breusch-Pagan Test",
    description: "Tests for heteroscedasticity in regression residuals.",
    assumptions: ["Linear regression model", "Residuals tested against predictors"],
    whenToUse: ["Checking constant variance", "Regression diagnostics", "Before inference"],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["durbin-watson", "quantile-regression", "robust-regression"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "vif",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Variance_inflation_factor",
    name: "Variance Inflation Factor (VIF)",
    description:
      "Quantifies multicollinearity in regression by measuring how much variance is inflated.",
    assumptions: ["Multiple regression context", "Linear relationships"],
    whenToUse: ["Detecting multicollinearity", "Variable selection", "Regression diagnostics"],
    category: "Assumption Testing",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["lasso-ridge", "elastic-net"],
    pythonCode: "",
    rCode: "",
  },

  // === POST-HOC TESTS ===
  {
    id: "tukey-hsd",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Tukey%27s_range_test",
    name: "Tukey's HSD",
    description:
      "Post-hoc test for pairwise comparisons after ANOVA, controlling family-wise error rate.",
    assumptions: ["Equal sample sizes (approximate)", "Equal variances", "Normal distribution"],
    whenToUse: ["All pairwise comparisons after ANOVA", "Balanced designs", "Conservative control"],
    category: "Post-hoc Tests",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["games-howell", "scheffe-test", "bonferroni", "holm-bonferroni"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "dunnett-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Dunnett%27s_test",
    name: "Dunnett's Test",
    description: "Compares multiple treatment groups to a single control group.",
    assumptions: ["Normal distribution", "Equal variances", "One control group"],
    whenToUse: ["Treatment vs control comparisons", "Not comparing treatments", "Drug trials"],
    category: "Post-hoc Tests",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["tukey-hsd", "bonferroni", "holm-bonferroni"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "games-howell",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Post_hoc_analysis",
    name: "Games-Howell Test",
    description: "Post-hoc test for unequal variances and/or unequal sample sizes.",
    assumptions: ["Does not assume equal variances", "Normal distribution"],
    whenToUse: ["Heterogeneous variances", "Unequal sample sizes", "After Welch's ANOVA"],
    category: "Post-hoc Tests",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["tukey-hsd", "scheffe-test", "welch-anova"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "scheffe-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Scheff%C3%A9%27s_method",
    name: "Scheffé's Test",
    description: "Most conservative post-hoc test, allows any linear contrast of means.",
    assumptions: ["Normal distribution", "Equal variances"],
    whenToUse: ["Complex contrasts", "Post-hoc hypothesis generation", "Maximum protection"],
    category: "Post-hoc Tests",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["tukey-hsd", "games-howell", "bonferroni", "holm-bonferroni"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "dunn-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_test",
    name: "Dunn's Test",
    description: "Non-parametric post-hoc test for pairwise comparisons after Kruskal-Wallis.",
    assumptions: ["Ordinal or continuous data", "Independent samples"],
    whenToUse: ["After Kruskal-Wallis", "Non-parametric multiple comparisons"],
    category: "Post-hoc Tests",
    outcome: "ordinal",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["kruskal-wallis", "bonferroni", "holm-bonferroni", "benjamini-hochberg"],
    pythonCode: "",
    rCode: "",
  },

  // === PVALUE ADJUSTMENTS ===
  {
    id: "bonferroni",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Bonferroni_correction",
    name: "Bonferroni Correction",
    description: "Simple adjustment for multiple comparisons by dividing alpha by number of tests.",
    assumptions: ["Independent or dependent tests", "Any test statistic"],
    whenToUse: ["Few comparisons", "Conservative correction", "General multiple testing"],
    category: "P-value Adjustments",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["holm-bonferroni", "benjamini-hochberg", "tukey-hsd"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "holm-bonferroni",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Holm%E2%80%93Bonferroni_method",
    name: "Holm-Bonferroni Method",
    description:
      "Step-down procedure that is uniformly more powerful than Bonferroni while controlling FWER.",
    assumptions: ["Any test statistic", "Ordered p-values"],
    whenToUse: ["Multiple comparisons", "More power than Bonferroni", "Sequential testing"],
    category: "P-value Adjustments",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["bonferroni", "benjamini-hochberg"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "benjamini-hochberg",
    wikipediaUrl: "https://en.wikipedia.org/wiki/False_discovery_rate",
    name: "Benjamini-Hochberg (FDR)",
    description:
      "Controls false discovery rate rather than family-wise error rate, more powerful for many tests.",
    assumptions: ["Independent or positively dependent tests", "Many hypotheses"],
    whenToUse: ["High-throughput testing", "Genomics", "Exploratory analysis"],
    category: "P-value Adjustments",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["holm-bonferroni", "bonferroni"],
    pythonCode: "",
    rCode: "",
  },

  // === ADDITIONAL GROUP COMPARISON ===
  {
    id: "welch-t-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Welch%27s_t-test",
    name: "Welch's t-Test",
    description: "Modification of t-test that does not assume equal variances between groups.",
    assumptions: [
      "Independent observations within and between groups",
      "Numeric outcome",
      "Difference in means ~ normal (or n large; no extreme outliers)",
    ],
    whenToUse: [
      "Compare means of two independent groups",
      "Variances and/or sample sizes differ",
      "Data roughly symmetric or n moderately large",
    ],
    category: "Group Comparison",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["mann-whitney", "t-test-independent", "permutation-test", "bootstrap", "bayesian-t-test"],
    pythonCode: `
# a and b are 1D arrays of observations
t_welch, p_val = scipy.stats.ttest_ind(a, b, equal_var=False)
    `.trim(),
    rCode: `
# a and b are numeric vectors of observations
t_welch <- t.test(a, b, var.equal = FALSE)
    `.trim(),
  },
  {
    id: "welch-anova",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Welch%27s_ANOVA",
    name: "Welch's ANOVA",
    description: "Robust alternative to one-way ANOVA when variances are unequal across groups.",
    assumptions: ["Normal distribution", "Independent samples", "Unequal variances allowed"],
    whenToUse: ["Heterogeneous variances", "Unbalanced designs", "Three or more groups"],
    category: "Group Comparison",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["one-way-anova", "kruskal-wallis", "games-howell", "permutation-test", "bootstrap", "bayesian-anova"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "ancova",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Analysis_of_covariance",
    name: "ANCOVA",
    description:
      "Analysis of covariance combining ANOVA with regression to control for covariates.",
    assumptions: [
      "Homogeneity of regression slopes",
      "Linear relationship with covariate",
      "Normal residuals",
    ],
    whenToUse: ["Adjusting for confounders", "Pre-test scores as covariate", "Increasing power"],
    category: "Group Comparison",
    outcome: "continuous",
    predictorStructure: "mixed",
    design: "independent",
    alternativeLinks: ["multiple-regression", "linear-mixed-model", "bayesian-regression"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "manova",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Multivariate_analysis_of_variance",
    name: "MANOVA",
    description:
      "Multivariate ANOVA testing group differences on multiple dependent variables simultaneously.",
    assumptions: ["Multivariate normality", "Homogeneity of covariance matrices", "Independence"],
    whenToUse: ["Multiple related outcomes", "Reducing Type I error", "Examining patterns"],
    category: "Group Comparison",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["two-way-anova"],
    pythonCode: "",
    rCode: "",
  },

  // === ADDITIONAL CORRELATION ===
  {
    id: "kendall-tau",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient",
    name: "Kendall's Tau",
    description:
      "Non-parametric measure of rank correlation, more robust than Spearman for small samples.",
    assumptions: ["Ordinal or continuous data", "Independent observations"],
    whenToUse: ["Small samples", "Many tied ranks", "Robust correlation estimate"],
    category: "Correlation",
    outcome: "ordinal",
    predictorStructure: "single continuous",
    design: "independent",
    alternativeLinks: ["spearman-correlation", "pearson-correlation"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "point-biserial",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Point-biserial_correlation_coefficient",
    name: "Point-Biserial Correlation",
    description: "Measures correlation between a continuous variable and a dichotomous variable.",
    assumptions: ["One continuous, one binary variable", "Normal distribution in groups"],
    whenToUse: ["Binary-continuous relationships", "Item analysis", "Effect size for t-test"],
    category: "Correlation",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["pearson-correlation", "spearman-correlation", "t-test-independent", "welch-t-test"],
    pythonCode: "",
    rCode: "",
  },

  // === ADDITIONAL CATEGORICAL ===
  {
    id: "cochran-q",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Cochran%27s_Q_test",
    name: "Cochran's Q Test",
    description: "Extension of McNemar test for comparing three or more matched proportions.",
    assumptions: ["Binary outcome", "Matched samples", "Three or more conditions"],
    whenToUse: ["Repeated measures binary data", "Multiple raters", "Before-during-after binary"],
    category: "Categorical",
    outcome: "binary",
    predictorStructure: "single categorical",
    design: "repeated",
    alternativeLinks: ["mcnemar-test", "friedman-test", "permutation-test"],
    pythonCode: "",
    rCode: "",
  },

  // === ADDITIONAL REGRESSION ===
  {
    id: "negative-binomial",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Negative_binomial_regression",
    name: "Negative Binomial Regression",
    description: "Models count data with overdispersion (variance greater than mean).",
    assumptions: ["Count outcome", "Overdispersion present", "Log-linear relationship"],
    whenToUse: ["Overdispersed counts", "Zero-inflated alternatives", "Event count modeling"],
    category: "Regression",
    outcome: "count",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["poisson-regression", "zero-inflated-poisson", "glmm", "gee"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "zero-inflated-poisson",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Zero-inflated_model",
    name: "Zero-Inflated Poisson",
    description: "Models count data with excess zeros using a two-part model.",
    assumptions: ["Count outcome", "Excess zeros", "Two processes generating data"],
    whenToUse: ["Many zeros in count data", "Structural and sampling zeros", "Two-stage process"],
    category: "Regression",
    outcome: "count",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["negative-binomial", "poisson-regression"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "quantile-regression",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Quantile_regression",
    name: "Quantile Regression",
    description: "Models conditional quantiles (e.g., median) rather than the mean.",
    assumptions: ["No distributional assumptions", "Continuous outcome"],
    whenToUse: ["Non-normal outcomes", "Heterogeneous effects", "Median modeling"],
    category: "Regression",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["robust-regression", "linear-regression", "multiple-regression"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "robust-regression",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Robust_regression",
    name: "Robust Regression",
    description: "Regression methods resistant to outliers and violations of assumptions.",
    assumptions: ["Linear relationship", "Potential outliers or leverage points"],
    whenToUse: ["Outliers present", "Heavy-tailed errors", "Robust inference"],
    category: "Regression",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["quantile-regression", "linear-regression", "multiple-regression", "bayesian-regression"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "probit-regression",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Probit_model",
    name: "Probit Regression",
    description: "Models binary outcomes using the cumulative normal distribution function.",
    assumptions: ["Binary outcome", "Latent variable interpretation", "Independence"],
    whenToUse: ["Binary classification", "Dose-response", "Latent variable models"],
    category: "Regression",
    outcome: "binary",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["logistic-regression", "bayesian-regression"],
    pythonCode: "",
    rCode: "",
  },

  // === ADDITIONAL ML METHODS ===
  {
    id: "svm",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Support-vector_machine",
    name: "Support Vector Machine (SVM)",
    description:
      "Finds optimal hyperplane to separate classes, can use kernels for non-linear boundaries.",
    assumptions: ["Scaled features recommended", "Sufficient training data"],
    whenToUse: ["Binary classification", "High-dimensional data", "Clear margin of separation"],
    category: "Machine Learning",
    outcome: "binary",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["logistic-regression", "random-forest", "gradient-boosting", "xgboost"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "xgboost",
    wikipediaUrl: "https://en.wikipedia.org/wiki/XGBoost",
    name: "XGBoost",
    description: "Optimized gradient boosting library with regularization and parallel processing.",
    assumptions: ["Sufficient training data", "Hyperparameter tuning required"],
    whenToUse: ["Structured/tabular data", "Kaggle competitions", "High accuracy needed"],
    category: "Machine Learning",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["gradient-boosting", "lightgbm", "catboost", "random-forest"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "lightgbm",
    wikipediaUrl: "https://en.wikipedia.org/wiki/LightGBM",
    name: "LightGBM",
    description: "Gradient boosting framework using leaf-wise tree growth for faster training.",
    assumptions: ["Large datasets", "Categorical features supported"],
    whenToUse: ["Large datasets", "Fast training needed", "Memory efficiency"],
    category: "Machine Learning",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["xgboost", "catboost", "gradient-boosting", "random-forest"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "catboost",
    wikipediaUrl: "https://en.wikipedia.org/wiki/CatBoost",
    name: "CatBoost",
    description: "Gradient boosting with native categorical feature support and ordered boosting.",
    assumptions: ["Categorical features present", "Sufficient training data"],
    whenToUse: ["Many categorical features", "Minimal preprocessing", "Prevent overfitting"],
    category: "Machine Learning",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["xgboost", "lightgbm", "gradient-boosting", "random-forest"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "knn",
    wikipediaUrl: "https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm",
    name: "k-Nearest Neighbors (k-NN)",
    description:
      "Classifies or predicts based on the k closest training examples in feature space.",
    assumptions: ["Meaningful distance metric", "Scaled features", "No noise dominance"],
    whenToUse: ["Simple baseline", "Non-linear patterns", "Instance-based learning"],
    category: "Machine Learning",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["svm", "random-forest", "gradient-boosting", "decision-tree"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "naive-bayes",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Naive_Bayes_classifier",
    name: "Naive Bayes",
    description: "Probabilistic classifier based on Bayes' theorem with independence assumption.",
    assumptions: ["Feature independence (often violated)", "Sufficient class representation"],
    whenToUse: ["Text classification", "Fast training needed", "Baseline model"],
    category: "Machine Learning",
    outcome: "binary",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["logistic-regression", "svm", "random-forest"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "decision-tree",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Decision_tree_learning",
    name: "Decision Tree",
    description: "Tree-structured model making sequential splits based on feature values.",
    assumptions: ["No strict distributional assumptions", "Sufficient training data"],
    whenToUse: ["Interpretable model needed", "Non-linear relationships", "Feature importance"],
    category: "Machine Learning",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["random-forest", "gradient-boosting", "xgboost"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "elastic-net",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Elastic_net_regularization",
    name: "Elastic Net",
    description: "Regularized regression combining L1 (Lasso) and L2 (Ridge) penalties.",
    assumptions: ["Linear relationships", "High-dimensional data possible"],
    whenToUse: [
      "Many correlated predictors",
      "Variable selection + shrinkage",
      "Combining Lasso and Ridge",
    ],
    category: "Machine Learning",
    outcome: "continuous",
    predictorStructure: "multiple continuous",
    design: "independent",
    alternativeLinks: ["lasso-ridge", "multiple-regression", "bayesian-regression"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "neural-network-mlp",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Multilayer_perceptron",
    name: "Neural Network (MLP)",
    description: "Multi-layer perceptron with hidden layers for learning complex patterns.",
    assumptions: ["Sufficient training data", "Scaled features", "Hyperparameter tuning"],
    whenToUse: ["Complex non-linear patterns", "Large datasets", "Deep learning baseline"],
    category: "Machine Learning",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["random-forest", "gradient-boosting", "xgboost", "lightgbm", "catboost"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "dbscan",
    wikipediaUrl: "https://en.wikipedia.org/wiki/DBSCAN",
    name: "DBSCAN",
    description:
      "Density-based clustering that finds arbitrarily shaped clusters and identifies outliers.",
    assumptions: ["Meaningful distance metric", "Similar density clusters"],
    whenToUse: ["Unknown number of clusters", "Non-spherical clusters", "Outlier detection"],
    category: "Clustering",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["gaussian-mixture", "hierarchical-clustering", "kmeans"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "gaussian-mixture",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Mixture_model",
    name: "Gaussian Mixture Model",
    description:
      "Probabilistic model assuming data comes from a mixture of Gaussian distributions.",
    assumptions: ["Gaussian clusters", "Known or estimated number of components"],
    whenToUse: ["Soft clustering", "Probabilistic assignment", "Elliptical clusters"],
    category: "Clustering",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["kmeans", "dbscan", "hierarchical-clustering"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "tsne",
    wikipediaUrl: "https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding",
    name: "t-SNE",
    description:
      "Non-linear dimensionality reduction technique for visualization of high-dimensional data.",
    assumptions: ["Local structure preservation", "Perplexity parameter choice"],
    whenToUse: ["Visualization", "Cluster exploration", "High-dimensional data"],
    category: "Dimension Reduction",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["umap", "pca"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "umap",
    wikipediaUrl: "https://en.wikipedia.org/wiki/UMAP",
    name: "UMAP",
    description:
      "Uniform Manifold Approximation for fast non-linear dimension reduction preserving global structure.",
    assumptions: ["Manifold assumption", "Sufficient neighbors"],
    whenToUse: ["Fast visualization", "Preserving global structure", "Large datasets"],
    category: "Dimension Reduction",
    outcome: "continuous",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["tsne", "pca"],
    pythonCode: "",
    rCode: "",
  },

  // === ADDITIONAL TIME SERIES ===
  {
    id: "prophet",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Prophet_(software)",
    name: "Prophet",
    description:
      "Automated forecasting procedure by Facebook for time series with seasonality and holidays.",
    assumptions: ["Regular time intervals", "Additive/multiplicative seasonality"],
    whenToUse: ["Business forecasting", "Multiple seasonality", "Missing data/outliers"],
    category: "Time Series",
    outcome: "continuous",
    predictorStructure: "none",
    design: "time-series",
    alternativeLinks: ["arima", "exponential-smoothing", "var"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "adf-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Augmented_Dickey%E2%80%93Fuller_test",
    name: "Augmented Dickey-Fuller Test",
    description: "Tests for unit root to determine if a time series is stationary.",
    assumptions: ["Time series data", "AR process"],
    whenToUse: ["Stationarity testing", "Before ARIMA modeling", "Cointegration analysis"],
    category: "Time Series",
    outcome: "continuous",
    predictorStructure: "none",
    design: "time-series",
    alternativeLinks: ["ljung-box", "arima"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "granger-causality",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Granger_causality",
    name: "Granger Causality Test",
    description: "Tests whether one time series helps predict another (temporal precedence).",
    assumptions: ["Stationary series", "Linear relationships", "No confounders"],
    whenToUse: ["Predictive causality", "Lead-lag relationships", "VAR models"],
    category: "Time Series",
    outcome: "continuous",
    predictorStructure: "multiple continuous",
    design: "time-series",
    alternativeLinks: ["var", "arima"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "ljung-box",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Ljung%E2%80%93Box_test",
    name: "Ljung-Box Test",
    description: "Tests whether any autocorrelations in a series are non-zero.",
    assumptions: ["Time series residuals", "Specified lag order"],
    whenToUse: ["Model diagnostics", "White noise testing", "ARIMA residual check"],
    category: "Time Series",
    outcome: "continuous",
    predictorStructure: "none",
    design: "time-series",
    alternativeLinks: ["durbin-watson", "adf-test"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "var",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Vector_autoregression",
    name: "Vector Autoregression (VAR)",
    description:
      "Models multiple time series where each variable depends on its own and others' past values.",
    assumptions: ["Stationary series", "Linear relationships", "Sufficient observations"],
    whenToUse: ["Multiple related time series", "Impulse response", "Forecasting systems"],
    category: "Time Series",
    outcome: "continuous",
    predictorStructure: "multiple continuous",
    design: "time-series",
    alternativeLinks: ["arima", "granger-causality", "prophet"],
    pythonCode: "",
    rCode: "",
  },

  // === BAYESIAN METHODS ===
  {
    id: "bayesian-t-test",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Bayes_factor",
    name: "Bayesian t-Test",
    description: "Bayesian alternative to t-test providing posterior probability of hypotheses.",
    assumptions: ["Prior specification", "Normal distribution"],
    whenToUse: [
      "Quantifying evidence for null",
      "Prior information available",
      "Uncertainty quantification",
    ],
    category: "Bayesian Methods",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["t-test-independent", "welch-t-test", "paired-t-test", "one-sample-t-test", "bayesian-anova"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "bayesian-regression",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Bayesian_linear_regression",
    name: "Bayesian Regression",
    description:
      "Regression with prior distributions on parameters, yielding posterior distributions.",
    assumptions: ["Prior specification", "Likelihood model"],
    whenToUse: ["Uncertainty quantification", "Prior knowledge incorporation", "Small samples"],
    category: "Bayesian Methods",
    outcome: "continuous",
    predictorStructure: "multiple mixed",
    design: "independent",
    alternativeLinks: ["linear-regression", "multiple-regression", "robust-regression", "quantile-regression"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "bayesian-anova",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Bayesian_statistics",
    name: "Bayesian ANOVA",
    description: "Bayesian approach to comparing group means with Bayes factors.",
    assumptions: ["Prior specification", "Normal distribution"],
    whenToUse: ["Evidence for null hypothesis", "Prior information", "Model comparison"],
    category: "Bayesian Methods",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["one-way-anova", "welch-anova", "bayesian-t-test"],
    pythonCode: "",
    rCode: "",
  },

  // === ADDITIONAL SURVIVAL ANALYSIS ===
  {
    id: "accelerated-failure-time",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Accelerated_failure_time_model",
    name: "Accelerated Failure Time Model",
    description:
      "Parametric survival model where covariates accelerate or decelerate time to event.",
    assumptions: [
      "Specified distribution (Weibull, log-normal)",
      "Multiplicative effect on survival time",
    ],
    whenToUse: [
      "Parametric survival",
      "Direct time interpretation",
      "When proportional hazards fails",
    ],
    category: "Survival Analysis",
    outcome: "time_to_event",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    alternativeLinks: ["cox-regression", "random-survival-forest"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "competing-risks",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Competing_risks",
    name: "Competing Risks Analysis",
    description: "Analyzes time-to-event when multiple event types can occur, only one observed.",
    assumptions: ["Mutually exclusive events", "Independent censoring"],
    whenToUse: ["Multiple failure types", "Cause-specific analysis", "Medical outcomes"],
    category: "Survival Analysis",
    outcome: "time_to_event",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    alternativeLinks: ["cox-regression", "kaplan-meier", "random-survival-forest"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "random-survival-forest",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Survival_analysis",
    name: "Random Survival Forest",
    description: "Extension of random forest to survival data with censoring.",
    assumptions: ["Sufficient training data", "Right-censored data"],
    whenToUse: [
      "Non-linear survival patterns",
      "Variable importance",
      "Prediction without proportional hazards",
    ],
    category: "Survival Analysis",
    outcome: "time_to_event",
    predictorStructure: "multiple mixed",
    design: "longitudinal",
    alternativeLinks: ["cox-regression", "accelerated-failure-time", "competing-risks"],
    pythonCode: "",
    rCode: "",
  },

  // === EFFECT SIZE MEASURES ===
  {
    id: "cohens-d",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Effect_size#Cohen%27s_d",
    name: "Cohen's d",
    description: "Standardized measure of effect size for difference between two means.",
    assumptions: ["Continuous outcome", "Two groups"],
    whenToUse: ["Reporting effect size", "Power analysis", "Meta-analysis"],
    category: "Effect Size",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["hedges-g", "eta-squared", "rank-biserial"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "hedges-g",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Effect_size#Hedges%27_g",
    name: "Hedges' g",
    description: "Bias-corrected version of Cohen's d for small sample sizes.",
    assumptions: ["Continuous outcome", "Two groups", "Small samples"],
    whenToUse: ["Small sample effect size", "Meta-analysis", "Unbiased estimate"],
    category: "Effect Size",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["cohens-d"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "eta-squared",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Effect_size#Eta-squared",
    name: "Eta-squared / Partial Eta-squared",
    description: "Proportion of variance explained by a factor in ANOVA designs.",
    assumptions: ["ANOVA context", "Continuous outcome"],
    whenToUse: ["ANOVA effect size", "Variance explained", "Reporting results"],
    category: "Effect Size",
    outcome: "continuous",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["omega-squared", "epsilon-squared"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "odds-ratio",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Odds_ratio",
    name: "Odds Ratio",
    description: "Ratio of odds of an event occurring in one group vs another.",
    assumptions: ["Binary outcome", "Two groups or conditions"],
    whenToUse: ["Case-control studies", "Logistic regression", "Risk communication"],
    category: "Effect Size",
    outcome: "binary",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["risk-ratio", "risk-difference", "phi-coefficient"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "cramers-v",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Cram%C3%A9r%27s_V",
    name: "Cramér's V",
    description: "Measure of association between two categorical variables, normalized chi-square.",
    assumptions: ["Nominal variables", "Contingency table"],
    whenToUse: ["Effect size for chi-square", "Comparing association strength", "Nominal data"],
    category: "Effect Size",
    outcome: "categorical",
    predictorStructure: "single categorical",
    design: "independent",
    alternativeLinks: ["phi-coefficient", "chi-square", "fisher-exact"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "omega-squared",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Effect_size#Omega-squared,_%CF%89%C2%B2",
    name: "Omega Squared (ω²)",
    description:
      "ANOVA effect size estimating the proportion of variance in the outcome attributable to a factor, with less upward bias than eta squared.",
    assumptions: [
      "Computed from an ANOVA model (one-way or factorial).",
      "Interpretation depends on the ANOVA design and correct model specification.",
    ],
    whenToUse: [
      "Report effect size for one-way or factorial ANOVA",
      "Prefer a less biased alternative to eta squared (η²)",
    ],
    category: "Effect Size",
    outcome: "continuous",
    predictorStructure: "categorical",
    design: "between",
    alternativeLinks: ["eta-squared"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "epsilon-squared",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Effect_size#Epsilon-squared,_%CE%B5%C2%B2",
    name: "Epsilon Squared (ε²)",
    description:
      "Rank-based effect size commonly used with nonparametric group comparisons (e.g., Kruskal-Wallis, Friedman) to quantify the strength of a group effect.",
    assumptions: [
      "Computed from a rank-based test statistic (e.g., H for Kruskal-Wallis, Q for Friedman).",
      "Different epsilon-squared variants exist; choose one and keep it consistent.",
    ],
    whenToUse: [
      "Report effect size for Kruskal-Wallis",
      "Report effect size for Friedman test",
      "Need a nonparametric analogue to variance-explained measures",
    ],
    category: "Effect Size",
    outcome: "ordinal",
    predictorStructure: "categorical",
    design: "between",
    alternativeLinks: ["rank-biserial", "eta-squared", "omega-squared"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "rank-biserial",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Rank_biserial_correlation",
    name: "Rank-Biserial Correlation",
    description:
      "Effect size for two-group rank tests (Mann-Whitney/Wilcoxon rank-sum) and paired Wilcoxon signed-rank tests, summarizing direction and strength using ranks.",
    assumptions: [
      "Outcome is at least ordinal; ranks are meaningful.",
      "Appropriate for two-group comparisons (independent or paired, depending on the underlying test).",
    ],
    whenToUse: [
      "Report effect size for Mann-Whitney U (Wilcoxon rank-sum)",
      "Report effect size for Wilcoxon signed-rank (paired)",
      "Need an interpretable rank-based effect size in [-1, 1]",
    ],
    category: "Effect Size",
    outcome: "ordinal",
    predictorStructure: "binary",
    design: "between",
    alternativeLinks: ["epsilon-squared", "cohens-d", "hedges-g"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "phi-coefficient",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Phi_coefficient",
    name: "Phi Coefficient (φ)",
    description:
      "Effect size measuring association between two binary variables in a 2x2 contingency table; equivalent to Pearson correlation for binary data.",
    assumptions: [
      "Both variables are binary and summarized in a 2x2 table.",
      "Interpretation depends on consistent coding if reporting a signed value.",
    ],
    whenToUse: [
      "Quantify association strength for a 2x2 contingency table",
      "Complement chi-square (2x2) or Fisher's exact test with an effect size",
    ],
    category: "Effect Size",
    outcome: "binary",
    predictorStructure: "binary",
    design: "between",
    alternativeLinks: ["cramers-v", "odds-ratio", "risk-ratio", "risk-difference"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "risk-ratio",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Relative_risk",
    name: "Risk Ratio (Relative Risk, RR)",
    description:
      "Effect size for binary outcomes comparing event risk (probability) between two groups as a ratio of risks.",
    assumptions: [
      "Binary outcome with two groups and well-defined risks p1 and p2.",
      "Group definitions (exposed vs control) should be explicit for interpretation.",
    ],
    whenToUse: [
      "Compare event risk between two groups",
      "Report an interpretable relative effect size for two proportions",
      "Complement a two-proportion test with an effect size",
    ],
    category: "Effect Size",
    outcome: "binary",
    predictorStructure: "binary",
    design: "between",
    alternativeLinks: ["risk-difference", "odds-ratio", "phi-coefficient"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "risk-difference",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Risk_difference",
    name: "Risk Difference (RD)",
    description:
      "Effect size for binary outcomes comparing event risk (probability) between two groups as an absolute difference in risks.",
    assumptions: [
      "Binary outcome with two groups and well-defined risks p1 and p2.",
      "Group definitions (treatment vs control) should be explicit for interpretation.",
    ],
    whenToUse: [
      "Compare absolute event risk between two groups",
      "Report absolute effect (practical impact) for two proportions",
      "Complement a two-proportion test with an absolute effect size",
    ],
    category: "Effect Size",
    outcome: "binary",
    predictorStructure: "binary",
    design: "between",
    alternativeLinks: ["risk-ratio", "odds-ratio", "phi-coefficient"],
    pythonCode: "",
    rCode: "",
  },

  // === AGREEMENT ===
  {
    id: "cohens-kappa",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Cohen%27s_kappa",
    name: "Cohen's Kappa",
    description:
      "Measures agreement between two raters for categorical items, adjusting for chance.",
    assumptions: ["Categorical data", "Two raters", "Same categories"],
    whenToUse: ["Inter-rater reliability", "Diagnostic agreement", "Coding reliability"],
    category: "Agreement",
    outcome: "categorical",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["fleiss-kappa", "intraclass-correlation"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "fleiss-kappa",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Fleiss%27_kappa",
    name: "Fleiss' Kappa",
    description: "Extends Cohen's kappa to measure agreement among three or more raters.",
    assumptions: ["Categorical data", "Multiple raters", "Fixed categories"],
    whenToUse: ["Multiple rater agreement", "Content analysis", "Medical diagnosis"],
    category: "Agreement",
    outcome: "categorical",
    predictorStructure: "none",
    design: "independent",
    alternativeLinks: ["cohens-kappa", "intraclass-correlation"],
    pythonCode: "",
    rCode: "",
  },
  {
    id: "intraclass-correlation",
    wikipediaUrl: "https://en.wikipedia.org/wiki/Intraclass_correlation",
    name: "Intraclass Correlation (ICC)",
    description:
      "Measures reliability or agreement for observations that are organized into groups.",
    assumptions: ["Grouped/clustered data", "Ratio or interval scale"],
    whenToUse: ["Inter-rater reliability", "Test-retest reliability", "Cluster analysis"],
    category: "Agreement",
    outcome: "continuous",
    predictorStructure: "none",
    design: "repeated",
    alternativeLinks: ["linear-mixed-model", "cohens-kappa", "fleiss-kappa"],
    pythonCode: "",
    rCode: "",
  },
];

export const categoryGroups = [
  {
    id: "one-sample",
    label: "One Sample",
    tests: ["one-sample-t-test", "one-proportion-z-test", "binomial-test"],
  },
  {
    id: "comparison",
    label: "Group Comparison",
    tests: [
      "t-test-independent",
      "paired-t-test",
      "one-way-anova",
      "two-way-anova",
      "repeated-measures-anova",
      "mann-whitney",
      "wilcoxon-signed-rank",
      "kruskal-wallis",
      "friedman-test",
      "welch-t-test",
      "welch-anova",
      "ancova",
      "manova",
    ],
  },
  {
    id: "correlation",
    label: "Correlation",
    tests: [
      "pearson-correlation",
      "spearman-correlation",
      "partial-correlation",
      "kendall-tau",
      "point-biserial",
    ],
  },
  {
    id: "regression",
    label: "Regression",
    tests: [
      "linear-regression",
      "multiple-regression",
      "logistic-regression",
      "poisson-regression",
      "ordinal-regression",
      "negative-binomial",
      "zero-inflated-poisson",
      "quantile-regression",
      "robust-regression",
      "probit-regression",
    ],
  },
  {
    id: "categorical",
    label: "Categorical",
    tests: [
      "chi-square",
      "chi-square-2x2",
      "fisher-exact",
      "mcnemar-test",
      "cochran-q",
      "two-proportion-z-test",
      "fisher-freeman-halton",
    ],
  },
  {
    id: "mixed",
    label: "Mixed Models",
    tests: ["linear-mixed-model", "glmm", "gee"],
  },
  {
    id: "time-series",
    label: "Time Series",
    tests: [
      "arima",
      "exponential-smoothing",
      "prophet",
      "adf-test",
      "granger-causality",
      "ljung-box",
      "var",
    ],
  },
  {
    id: "survival",
    label: "Survival Analysis",
    tests: [
      "kaplan-meier",
      "log-rank-test",
      "cox-regression",
      "accelerated-failure-time",
      "competing-risks",
      "random-survival-forest",
    ],
  },
  {
    id: "clustering",
    label: "Clustering",
    tests: ["kmeans", "hierarchical-clustering", "dbscan", "gaussian-mixture"],
  },
  {
    id: "dimension",
    label: "Dimension Reduction",
    tests: ["pca", "factor-analysis", "tsne", "umap"],
  },
  {
    id: "ml",
    label: "Machine Learning",
    tests: [
      "random-forest",
      "gradient-boosting",
      "lasso-ridge",
      "svm",
      "xgboost",
      "lightgbm",
      "catboost",
      "knn",
      "naive-bayes",
      "decision-tree",
      "elastic-net",
      "neural-network-mlp",
    ],
  },
  {
    id: "resampling",
    label: "Resampling",
    tests: ["bootstrap", "permutation-test", "cross-validation", "jackknife"],
  },
  {
    id: "assumption",
    label: "Diagnostics & Assumptions",
    tests: [
      "levene-test",
      "bartlett-test",
      "brown-forsythe",
      "fligner-killeen",
      "hartley-fmax",
      "shapiro-wilk",
      "kolmogorov-smirnov",
      "anderson-darling",
      "dagostino-pearson",
      "durbin-watson",
      "breusch-pagan",
      "vif",
    ],
  },
  {
    id: "posthoc",
    label: "Post-hoc Tests",
    tests: ["tukey-hsd", "dunnett-test", "games-howell", "scheffe-test", "dunn-test"],
  },
  {
    id: "padjust",
    label: "P-value Adjustments",
    tests: ["bonferroni", "holm-bonferroni", "benjamini-hochberg"],
  },
  {
    id: "bayesian",
    label: "Bayesian Methods",
    tests: ["bayesian-t-test", "bayesian-regression", "bayesian-anova"],
  },
  {
    id: "effectsize",
    label: "Effect Size",
    tests: [
      "cohens-d",
      "hedges-g",
      "eta-squared",
      "odds-ratio",
      "cramers-v",
      "omega-squared",
      "epsilon-squared",
      "rank-biserial",
      "phi-coefficient",
      "risk-ratio",
      "risk-difference",
    ],
  },
  {
    id: "agreement",
    label: "Agreement",
    tests: ["cohens-kappa", "fleiss-kappa", "intraclass-correlation"],
  },
  {
    id: "planning",
    label: "Study Planning",
    tests: ["power-analysis"],
  },
];